{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "moviesdatafactoryetl"
		},
		"AzureSqlDatabase1_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'AzureSqlDatabase1'"
		},
		"landing_blob_linked_service_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'landing_blob_linked_service'"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/1 extract')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "load_landing",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "load_landing",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"bloblanding": {},
									"tomoviesdblanding": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": [],
				"lastPublishTime": "2023-08-22T03:32:26Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/load_landing')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/2 load map')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "load_map_actor",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "load_map_actor",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"landMovies": {},
									"targetMapActors": {},
									"loadintomapactors": {},
									"insertMapActor": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "load_map_genre",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "load_map_genre",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"landingmovies": {},
									"targetMapGenre": {},
									"insertMapGenre": {},
									"updateMapGenre": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "load_map_dir",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "load_map_dir",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"landingmovies": {},
									"targertMapDirector": {},
									"updateMapDir": {},
									"insertMapDir": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "load_map_year",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "load_map_year",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"landingmovies": {},
									"targetMapYear": {},
									"insertMapYear": {},
									"updateMapYear": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "load_map_film",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "load_map_film",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"landmovies": {},
									"targetMapFilm": {},
									"insertMapFilm": {},
									"updateMapFilm": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/load_map_actor')]",
				"[concat(variables('factoryId'), '/dataflows/load_map_genre')]",
				"[concat(variables('factoryId'), '/dataflows/load_map_dir')]",
				"[concat(variables('factoryId'), '/dataflows/load_map_year')]",
				"[concat(variables('factoryId'), '/dataflows/load_map_film')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/3 load stg')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "load_stg_actor_film_assoc",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "load_stg_actor_film_assoc",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"landingmovies": {},
									"mapactor": {},
									"mapfilm": {},
									"insertStgActorFilmAssoc": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "load_stg_actor",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "load_stg_actor",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"landmovies": {},
									"mapactor": {},
									"stgactor": {},
									"insertstgactor": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "load_stg_genre_film_assoc",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "load_stg_genre_film_assoc",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"landmovies": {},
									"mapgenre": {},
									"mapfilm": {},
									"sinkStgGenreFilmAssoc": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "load_stg_genre",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "load_stg_genre",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"landingmovies": {},
									"mapgenre": {},
									"sinkStgGenre": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "load_stg_film",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "load_stg_film",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"landingmovie": {},
									"mapfilm": {},
									"insertStgFilm": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/load_stg_actor_film_assoc')]",
				"[concat(variables('factoryId'), '/dataflows/load_stg_actor')]",
				"[concat(variables('factoryId'), '/dataflows/load_stg_genre_film_assoc')]",
				"[concat(variables('factoryId'), '/dataflows/load_stg_genre')]",
				"[concat(variables('factoryId'), '/dataflows/load_stg_film')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/4 load dim')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "load_dim_movie",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "load_dim_movie",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"stgfilm": {},
									"targetDimMovie": {},
									"updateDimMovie": {},
									"insertDimMovie": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "load_dim_genre_movie_assoc",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "load_dim_genre_movie_assoc",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"stggenrefilmassoc": {},
									"targetDimGenreFilmAssoc": {},
									"insertDimGenreFilmAssoc": {},
									"updateDimGenreFilmAssoc": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "load_dim_actor",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "load_dim_actor",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"stgactor": {},
									"targetDimActor": {},
									"updateDimActor": {},
									"insertDimActor": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "load_dim_movie_actor_assoc",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "load_dim_actor_movie_assoc",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"stgactorfilmassoc": {},
									"targetdimactorfilmassoc": {},
									"sinkDimActorFilmAssoc": {},
									"updateDimActorFilmAssoc": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "load_dim_dir",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "load_dim_dir",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"mapdir": {},
									"targetDimDir": {},
									"insertDimDir": {},
									"updateDimDir": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "load_dim_year",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "load_dim_year",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"mapyear": {},
									"targetDimYear": {},
									"insertDimYear": {},
									"updateDimYear": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "load_dim_genre",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "load_dim_genre",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"stggenre": {},
									"targetdimgenre": {},
									"insertDimGenre": {},
									"updateDimGenre": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/load_dim_movie')]",
				"[concat(variables('factoryId'), '/dataflows/load_dim_genre_movie_assoc')]",
				"[concat(variables('factoryId'), '/dataflows/load_dim_actor')]",
				"[concat(variables('factoryId'), '/dataflows/load_dim_actor_movie_assoc')]",
				"[concat(variables('factoryId'), '/dataflows/load_dim_dir')]",
				"[concat(variables('factoryId'), '/dataflows/load_dim_year')]",
				"[concat(variables('factoryId'), '/dataflows/load_dim_genre')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/5 load fact')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "load_fact_film",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "load_fact_film",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"stgfilm": {},
									"mapdirector": {},
									"mapyear": {},
									"mapfilm": {},
									"targetFactFilm": {},
									"insertFactFilm": {},
									"updateFactFilm": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/load_fact_film')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pipelines 2_3_4_5')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "2 load map",
						"type": "ExecutePipeline",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "2 load map",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "3 load stg",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "2 load map",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "3 load stg",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "4 load dim",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "3 load stg",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "4 load dim",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "5 load fact",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "4 load dim",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "5 load fact",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/2 load map')]",
				"[concat(variables('factoryId'), '/pipelines/3 load stg')]",
				"[concat(variables('factoryId'), '/pipelines/4 load dim')]",
				"[concat(variables('factoryId'), '/pipelines/5 load fact')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/blob_land_movies')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "landing_blob_linked_service",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "01 landing"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobStorageLocation",
						"fileName": "IMDB-Movie-Data_no_double_quotes.csv",
						"container": "moviedata"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Rank",
						"type": "String"
					},
					{
						"name": "Title",
						"type": "String"
					},
					{
						"name": "Genre",
						"type": "String"
					},
					{
						"name": "Description",
						"type": "String"
					},
					{
						"name": "Director",
						"type": "String"
					},
					{
						"name": "Actors",
						"type": "String"
					},
					{
						"name": "Year",
						"type": "String"
					},
					{
						"name": "Runtime (Minutes)",
						"type": "String"
					},
					{
						"name": "Rating",
						"type": "String"
					},
					{
						"name": "Votes",
						"type": "String"
					},
					{
						"name": "Revenue (Millions)",
						"type": "String"
					},
					{
						"name": "Metascore",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/landing_blob_linked_service')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/dim_actor')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureSqlDatabase1",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "actor_id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "actor",
						"type": "nvarchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "dim_actor"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureSqlDatabase1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/dim_actor_movie_assoc')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureSqlDatabase1",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "dim_actor_movie_assoc_id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "actor_id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "film_id",
						"type": "int",
						"precision": 10
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "dim_actor_movie_assoc"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureSqlDatabase1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/dim_dir')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureSqlDatabase1",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "director_id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "director",
						"type": "nvarchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "dim_director"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureSqlDatabase1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/dim_genre')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureSqlDatabase1",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "genre_id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "genre",
						"type": "nvarchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "dim_genre"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureSqlDatabase1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/dim_genre_movie_assoc')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureSqlDatabase1",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "dim_genre_movie_assoc_id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "genre_id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "film_id",
						"type": "int",
						"precision": 10
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "dim_genre_movie_assoc"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureSqlDatabase1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/dim_movie')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureSqlDatabase1",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "film_id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "title",
						"type": "nvarchar"
					},
					{
						"name": "description",
						"type": "nvarchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "dim_movie"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureSqlDatabase1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/dim_year')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureSqlDatabase1",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "date_id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "year",
						"type": "int",
						"precision": 10
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "dim_year"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureSqlDatabase1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/fact_film')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureSqlDatabase1",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "runtime_minutes",
						"type": "float",
						"precision": 15
					},
					{
						"name": "rating",
						"type": "float",
						"precision": 15
					},
					{
						"name": "revenue_millions",
						"type": "float",
						"precision": 15
					},
					{
						"name": "votes",
						"type": "int",
						"precision": 10
					},
					{
						"name": "metascore",
						"type": "int",
						"precision": 10
					},
					{
						"name": "film_id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "director_id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "year_id",
						"type": "int",
						"precision": 10
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "fact_film"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureSqlDatabase1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/map_actor')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureSqlDatabase1",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "02 stg and map"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "actor_id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "actor",
						"type": "nvarchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "map_actor"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureSqlDatabase1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/map_director')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureSqlDatabase1",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "director_id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "director",
						"type": "nvarchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "map_director"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureSqlDatabase1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/map_film')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureSqlDatabase1",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "02 stg and map"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "film_id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "title",
						"type": "nvarchar"
					},
					{
						"name": "film_year",
						"type": "int",
						"precision": 10
					},
					{
						"name": "director",
						"type": "nvarchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "map_film"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureSqlDatabase1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/map_genre')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureSqlDatabase1",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "02 stg and map"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "genre_id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "genre",
						"type": "nvarchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "map_genre"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureSqlDatabase1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/map_year')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureSqlDatabase1",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "year_id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "year",
						"type": "int",
						"precision": 10
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "map_year"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureSqlDatabase1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/move_db_landing')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureSqlDatabase1",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "01 landing"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "Rank",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "Title",
						"type": "nvarchar"
					},
					{
						"name": "Genre",
						"type": "nvarchar"
					},
					{
						"name": "Description",
						"type": "varchar"
					},
					{
						"name": "Director",
						"type": "nvarchar"
					},
					{
						"name": "Actors",
						"type": "nvarchar"
					},
					{
						"name": "Year",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "Runtime_Minutes",
						"type": "tinyint",
						"precision": 3
					},
					{
						"name": "Rating",
						"type": "float",
						"precision": 15
					},
					{
						"name": "Votes",
						"type": "int",
						"precision": 10
					},
					{
						"name": "Revenue_Millions",
						"type": "float",
						"precision": 15
					},
					{
						"name": "Metascore",
						"type": "tinyint",
						"precision": 3
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "land_movies"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureSqlDatabase1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/stg_actor')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureSqlDatabase1",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "02 stg and map"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "actor_id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "actor",
						"type": "nvarchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "stg_actor"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureSqlDatabase1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/stg_actor_film_assoc')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureSqlDatabase1",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "02 stg and map"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "stg_actor_film_id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "actor_id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "film_id",
						"type": "int",
						"precision": 10
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "stg_actor_film_assoc"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureSqlDatabase1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/stg_film')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureSqlDatabase1",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "02 stg and map"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "film_id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "title",
						"type": "nvarchar"
					},
					{
						"name": "description",
						"type": "nvarchar"
					},
					{
						"name": "director",
						"type": "nvarchar"
					},
					{
						"name": "film_year",
						"type": "int",
						"precision": 10
					},
					{
						"name": "runtime_minutes",
						"type": "int",
						"precision": 10
					},
					{
						"name": "rating",
						"type": "float",
						"precision": 15
					},
					{
						"name": "votes",
						"type": "int",
						"precision": 10
					},
					{
						"name": "revenue_millions",
						"type": "float",
						"precision": 15
					},
					{
						"name": "metascore",
						"type": "int",
						"precision": 10
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "stg_film"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureSqlDatabase1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/stg_genre')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureSqlDatabase1",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "02 stg and map"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "genre_id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "genre",
						"type": "nvarchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "stg_genre"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureSqlDatabase1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/stg_genre_film_assoc')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureSqlDatabase1",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "02 stg and map"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "stg_genre_film_id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "genre_id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "film_id",
						"type": "int",
						"precision": 10
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "stg_genre_film_assoc"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureSqlDatabase1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/temp_actor_year_title_dir')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureSqlDatabase1",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "02 stg and map"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "Actors",
						"type": "nvarchar"
					},
					{
						"name": "Title",
						"type": "nvarchar"
					},
					{
						"name": "Director",
						"type": "nvarchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "temp_actor_title_year_dir"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureSqlDatabase1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/AzureSqlDatabase1')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "AzureSqlDatabase",
				"typeProperties": {
					"connectionString": "[parameters('AzureSqlDatabase1_connectionString')]"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/landing_blob_linked_service')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "AzureBlobStorage",
				"typeProperties": {
					"connectionString": "[parameters('landing_blob_linked_service_connectionString')]"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_dim_actor')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "stg_actor",
								"type": "DatasetReference"
							},
							"name": "stgactor"
						},
						{
							"dataset": {
								"referenceName": "dim_actor",
								"type": "DatasetReference"
							},
							"name": "targetDimActor"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "dim_actor",
								"type": "DatasetReference"
							},
							"name": "updateDimActor"
						},
						{
							"dataset": {
								"referenceName": "dim_actor",
								"type": "DatasetReference"
							},
							"name": "insertDimActor"
						}
					],
					"transformations": [
						{
							"name": "existsUpdate"
						},
						{
							"name": "notExistsInsert"
						},
						{
							"name": "updateif"
						}
					],
					"scriptLines": [
						"source(output(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stgactor",
						"source(output(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetDimActor",
						"stgactor, targetDimActor join(stgactor@actor_id == targetDimActor@actor_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsUpdate",
						"stgactor, targetDimActor exists(stgactor@actor == targetDimActor@actor,",
						"     negate:true,",
						"     broadcast: 'auto')~> notExistsInsert",
						"existsUpdate alterRow(updateIf(notEquals(iifNull(stgactor@actor,'NULL',stgactor@actor),iifNull(targetDimActor@actor,'NULL',targetDimActor@actor)))) ~> updateif",
						"updateif sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['actor_id'],",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          actor_id = stgactor@actor_id,",
						"          actor = stgactor@actor",
						"     )) ~> updateDimActor",
						"notExistsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          actor_id,",
						"          actor",
						"     )) ~> insertDimActor"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/stg_actor')]",
				"[concat(variables('factoryId'), '/datasets/dim_actor')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_dim_actor_movie_assoc')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "stg_actor_film_assoc",
								"type": "DatasetReference"
							},
							"name": "stgactorfilmassoc"
						},
						{
							"dataset": {
								"referenceName": "dim_actor_movie_assoc",
								"type": "DatasetReference"
							},
							"name": "targetdimactorfilmassoc"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "dim_actor_movie_assoc",
								"type": "DatasetReference"
							},
							"name": "sinkDimActorFilmAssoc"
						},
						{
							"dataset": {
								"referenceName": "dim_actor_movie_assoc",
								"type": "DatasetReference"
							},
							"name": "updateDimActorFilmAssoc"
						}
					],
					"transformations": [
						{
							"name": "notExistsInsert"
						},
						{
							"name": "existsUpdate"
						},
						{
							"name": "updateIf"
						}
					],
					"scriptLines": [
						"source(output(",
						"          stg_actor_film_id as integer,",
						"          actor_id as integer,",
						"          film_id as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stgactorfilmassoc",
						"source(output(",
						"          dim_actor_movie_assoc_id as integer,",
						"          actor_id as integer,",
						"          film_id as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetdimactorfilmassoc",
						"stgactorfilmassoc, targetdimactorfilmassoc exists(stg_actor_film_id == dim_actor_movie_assoc_id,",
						"     negate:true,",
						"     broadcast: 'auto')~> notExistsInsert",
						"stgactorfilmassoc, targetdimactorfilmassoc join(stg_actor_film_id == dim_actor_movie_assoc_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsUpdate",
						"existsUpdate alterRow(updateIf(notEquals(iifNull(stgactorfilmassoc@actor_id,-1,stgactorfilmassoc@actor_id),iifNull(targetdimactorfilmassoc@actor_id,-1,targetdimactorfilmassoc@actor_id)))) ~> updateIf",
						"notExistsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          dim_actor_movie_assoc_id as integer,",
						"          actor_id as integer,",
						"          film_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          dim_actor_movie_assoc_id = stg_actor_film_id,",
						"          actor_id,",
						"          film_id",
						"     )) ~> sinkDimActorFilmAssoc",
						"updateIf sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          dim_actor_movie_assoc_id as integer,",
						"          actor_id as integer,",
						"          film_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['dim_actor_movie_assoc_id'],",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          dim_actor_movie_assoc_id,",
						"          actor_id = stgactorfilmassoc@actor_id,",
						"          film_id = stgactorfilmassoc@film_id",
						"     )) ~> updateDimActorFilmAssoc"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/stg_actor_film_assoc')]",
				"[concat(variables('factoryId'), '/datasets/dim_actor_movie_assoc')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_dim_dir')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "map_director",
								"type": "DatasetReference"
							},
							"name": "mapdir"
						},
						{
							"dataset": {
								"referenceName": "dim_dir",
								"type": "DatasetReference"
							},
							"name": "targetDimDir"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "dim_dir",
								"type": "DatasetReference"
							},
							"name": "insertDimDir"
						},
						{
							"dataset": {
								"referenceName": "dim_dir",
								"type": "DatasetReference"
							},
							"name": "updateDimDir"
						}
					],
					"transformations": [
						{
							"name": "notExistsInsert"
						},
						{
							"name": "existsUpdate"
						},
						{
							"name": "updateIf"
						}
					],
					"scriptLines": [
						"source(output(",
						"          director_id as integer,",
						"          director as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapdir",
						"source(output(",
						"          director_id as integer,",
						"          director as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetDimDir",
						"mapdir, targetDimDir exists(mapdir@director_id == targetDimDir@director_id,",
						"     negate:true,",
						"     broadcast: 'auto')~> notExistsInsert",
						"mapdir, targetDimDir join(mapdir@director_id == targetDimDir@director_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsUpdate",
						"existsUpdate alterRow(updateIf(notEquals(iifNull(mapdir@director,'NULL',mapdir@director),iifNull(targetDimDir@director,'NULL',targetDimDir@director)))) ~> updateIf",
						"notExistsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          director_id as integer,",
						"          director as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          director_id,",
						"          director",
						"     )) ~> insertDimDir",
						"updateIf sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          director_id as integer,",
						"          director as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['director_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          director_id = mapdir@director_id,",
						"          director = mapdir@director",
						"     )) ~> updateDimDir"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/map_director')]",
				"[concat(variables('factoryId'), '/datasets/dim_dir')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_dim_genre')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "stg_genre",
								"type": "DatasetReference"
							},
							"name": "stggenre"
						},
						{
							"dataset": {
								"referenceName": "dim_genre",
								"type": "DatasetReference"
							},
							"name": "targetdimgenre"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "dim_genre",
								"type": "DatasetReference"
							},
							"name": "insertDimGenre"
						},
						{
							"dataset": {
								"referenceName": "dim_genre",
								"type": "DatasetReference"
							},
							"name": "updateDimGenre"
						}
					],
					"transformations": [
						{
							"name": "notExistsInsert"
						},
						{
							"name": "existsUpdate"
						},
						{
							"name": "updateIf"
						}
					],
					"scriptLines": [
						"source(output(",
						"          genre_id as integer,",
						"          genre as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stggenre",
						"source(output(",
						"          genre_id as integer,",
						"          genre as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetdimgenre",
						"stggenre, targetdimgenre exists(stggenre@genre_id == targetdimgenre@genre_id,",
						"     negate:true,",
						"     broadcast: 'auto')~> notExistsInsert",
						"stggenre, targetdimgenre join(stggenre@genre_id == targetdimgenre@genre_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsUpdate",
						"existsUpdate alterRow(updateIf(notEquals(iifNull(stggenre@genre,'NULL',stggenre@genre),iifNull(targetdimgenre@genre,'NULL',targetdimgenre@genre)))) ~> updateIf",
						"notExistsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          genre_id as integer,",
						"          genre as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          genre_id,",
						"          genre",
						"     )) ~> insertDimGenre",
						"updateIf sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          genre_id as integer,",
						"          genre as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['genre_id'],",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          genre_id = stggenre@genre_id,",
						"          genre = stggenre@genre",
						"     )) ~> updateDimGenre"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/stg_genre')]",
				"[concat(variables('factoryId'), '/datasets/dim_genre')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_dim_genre_movie_assoc')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "stg_genre_film_assoc",
								"type": "DatasetReference"
							},
							"name": "stggenrefilmassoc"
						},
						{
							"dataset": {
								"referenceName": "dim_genre_movie_assoc",
								"type": "DatasetReference"
							},
							"name": "targetDimGenreFilmAssoc"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "dim_genre_movie_assoc",
								"type": "DatasetReference"
							},
							"name": "insertDimGenreFilmAssoc"
						},
						{
							"dataset": {
								"referenceName": "dim_genre_movie_assoc",
								"type": "DatasetReference"
							},
							"name": "updateDimGenreFilmAssoc"
						}
					],
					"transformations": [
						{
							"name": "notExistsInsert"
						},
						{
							"name": "existsUpdate"
						},
						{
							"name": "updateIf"
						}
					],
					"scriptLines": [
						"source(output(",
						"          stg_genre_film_id as integer,",
						"          genre_id as integer,",
						"          film_id as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stggenrefilmassoc",
						"source(output(",
						"          dim_genre_movie_assoc_id as integer,",
						"          genre_id as integer,",
						"          film_id as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetDimGenreFilmAssoc",
						"stggenrefilmassoc, targetDimGenreFilmAssoc exists(stg_genre_film_id == dim_genre_movie_assoc_id,",
						"     negate:true,",
						"     broadcast: 'auto')~> notExistsInsert",
						"stggenrefilmassoc, targetDimGenreFilmAssoc join(stg_genre_film_id == dim_genre_movie_assoc_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsUpdate",
						"existsUpdate alterRow(updateIf(notEquals(iifNull(stggenrefilmassoc@genre_id,-1,stggenrefilmassoc@genre_id),iifNull(targetDimGenreFilmAssoc@genre_id,-1,targetDimGenreFilmAssoc@genre_id))),",
						"     updateIf(notEquals(iifNull(stggenrefilmassoc@film_id,-1,stggenrefilmassoc@film_id),iifNull(targetDimGenreFilmAssoc@film_id,-1,targetDimGenreFilmAssoc@film_id)))) ~> updateIf",
						"notExistsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          dim_genre_movie_assoc_id as integer,",
						"          genre_id as integer,",
						"          film_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          dim_genre_movie_assoc_id = stg_genre_film_id,",
						"          genre_id,",
						"          film_id",
						"     )) ~> insertDimGenreFilmAssoc",
						"updateIf sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          dim_genre_movie_assoc_id as integer,",
						"          genre_id as integer,",
						"          film_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['dim_genre_movie_assoc_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          dim_genre_movie_assoc_id,",
						"          genre_id = stggenrefilmassoc@genre_id,",
						"          film_id = stggenrefilmassoc@film_id",
						"     )) ~> updateDimGenreFilmAssoc"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/stg_genre_film_assoc')]",
				"[concat(variables('factoryId'), '/datasets/dim_genre_movie_assoc')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_dim_movie')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "stg_film",
								"type": "DatasetReference"
							},
							"name": "stgfilm"
						},
						{
							"dataset": {
								"referenceName": "dim_movie",
								"type": "DatasetReference"
							},
							"name": "targetDimMovie"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "dim_movie",
								"type": "DatasetReference"
							},
							"name": "updateDimMovie"
						},
						{
							"dataset": {
								"referenceName": "dim_movie",
								"type": "DatasetReference"
							},
							"name": "insertDimMovie"
						}
					],
					"transformations": [
						{
							"name": "existsUpdate"
						},
						{
							"name": "notExistsInsert"
						},
						{
							"name": "updateIf"
						}
					],
					"scriptLines": [
						"source(output(",
						"          film_id as integer,",
						"          title as string,",
						"          description as string,",
						"          director as string,",
						"          film_year as integer,",
						"          runtime_minutes as integer,",
						"          rating as double,",
						"          votes as integer,",
						"          revenue_millions as double,",
						"          metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stgfilm",
						"source(output(",
						"          film_id as integer,",
						"          title as string,",
						"          description as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetDimMovie",
						"stgfilm, targetDimMovie join(stgfilm@film_id == targetDimMovie@film_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsUpdate",
						"stgfilm, targetDimMovie exists(stgfilm@film_id == targetDimMovie@film_id,",
						"     negate:true,",
						"     broadcast: 'auto')~> notExistsInsert",
						"existsUpdate alterRow(updateIf(notEquals(iifNull(stgfilm@title,'NULL',stgfilm@title),iifNull(targetDimMovie@title,'NULL',targetDimMovie@title))),",
						"     updateIf(notEquals(iifNull(stgfilm@description,'NULL',stgfilm@description),iifNull(targetDimMovie@description,'NULL',targetDimMovie@description)))) ~> updateIf",
						"updateIf sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          film_id as integer,",
						"          title as string,",
						"          description as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['film_id'],",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          film_id = targetDimMovie@film_id,",
						"          title = stgfilm@title,",
						"          description = stgfilm@description",
						"     )) ~> updateDimMovie",
						"notExistsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          film_id as integer,",
						"          title as string,",
						"          description as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          film_id,",
						"          title,",
						"          description",
						"     )) ~> insertDimMovie"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/stg_film')]",
				"[concat(variables('factoryId'), '/datasets/dim_movie')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_dim_year')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "map_year",
								"type": "DatasetReference"
							},
							"name": "mapyear"
						},
						{
							"dataset": {
								"referenceName": "dim_year",
								"type": "DatasetReference"
							},
							"name": "targetDimYear"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "dim_year",
								"type": "DatasetReference"
							},
							"name": "insertDimYear"
						},
						{
							"dataset": {
								"referenceName": "dim_year",
								"type": "DatasetReference"
							},
							"name": "updateDimYear"
						}
					],
					"transformations": [
						{
							"name": "notExistsInsert"
						},
						{
							"name": "existsUpdate"
						},
						{
							"name": "updateIf"
						}
					],
					"scriptLines": [
						"source(output(",
						"          year_id as integer,",
						"          year as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapyear",
						"source(output(",
						"          date_id as integer,",
						"          year as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetDimYear",
						"mapyear, targetDimYear exists(year_id == date_id,",
						"     negate:true,",
						"     broadcast: 'auto')~> notExistsInsert",
						"mapyear, targetDimYear join(year_id == date_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsUpdate",
						"existsUpdate alterRow(updateIf(notEquals(iifNull(mapyear@year,-1,mapyear@year),iifNull(targetDimYear@year,-1,targetDimYear@year)))) ~> updateIf",
						"notExistsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          date_id as integer,",
						"          year as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          date_id = year_id,",
						"          year",
						"     )) ~> insertDimYear",
						"updateIf sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          date_id as integer,",
						"          year as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['date_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          date_id = year_id,",
						"          year = mapyear@year",
						"     )) ~> updateDimYear"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/map_year')]",
				"[concat(variables('factoryId'), '/datasets/dim_year')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_fact_film')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "stg_film",
								"type": "DatasetReference"
							},
							"name": "stgfilm"
						},
						{
							"dataset": {
								"referenceName": "map_director",
								"type": "DatasetReference"
							},
							"name": "mapdirector"
						},
						{
							"dataset": {
								"referenceName": "map_year",
								"type": "DatasetReference"
							},
							"name": "mapyear"
						},
						{
							"dataset": {
								"referenceName": "map_film",
								"type": "DatasetReference"
							},
							"name": "mapfilm"
						},
						{
							"dataset": {
								"referenceName": "fact_film",
								"type": "DatasetReference"
							},
							"name": "targetFactFilm"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "fact_film",
								"type": "DatasetReference"
							},
							"name": "insertFactFilm"
						},
						{
							"dataset": {
								"referenceName": "fact_film",
								"type": "DatasetReference"
							},
							"name": "updateFactFilm"
						}
					],
					"transformations": [
						{
							"name": "joinMapDirector"
						},
						{
							"name": "joinMapYear"
						},
						{
							"name": "joinMapFilm"
						},
						{
							"name": "selectColumns"
						},
						{
							"name": "selectColumnsFinal"
						},
						{
							"name": "notExistsInsert"
						},
						{
							"name": "existsUpdate"
						},
						{
							"name": "updateIf"
						}
					],
					"scriptLines": [
						"source(output(",
						"          film_id as integer,",
						"          title as string,",
						"          description as string,",
						"          director as string,",
						"          film_year as integer,",
						"          runtime_minutes as integer,",
						"          rating as double,",
						"          votes as integer,",
						"          revenue_millions as double,",
						"          metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stgfilm",
						"source(output(",
						"          director_id as integer,",
						"          director as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapdirector",
						"source(output(",
						"          year_id as integer,",
						"          year as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapyear",
						"source(output(",
						"          film_id as integer,",
						"          title as string,",
						"          film_year as integer,",
						"          director as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapfilm",
						"source(output(",
						"          runtime_minutes as double,",
						"          rating as double,",
						"          revenue_millions as double,",
						"          votes as integer,",
						"          metascore as integer,",
						"          film_id as integer,",
						"          director_id as integer,",
						"          year_id as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetFactFilm",
						"stgfilm, mapdirector join(stgfilm@director == mapdirector@director,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinMapDirector",
						"joinMapDirector, mapyear join(film_year == year,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinMapYear",
						"joinMapYear, mapfilm join(stgfilm@film_id == mapfilm@film_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinMapFilm",
						"joinMapFilm select(mapColumn(",
						"          film_id = stgfilm@film_id,",
						"          film_year = stgfilm@film_year,",
						"          runtime_minutes,",
						"          rating,",
						"          votes,",
						"          revenue_millions,",
						"          metascore,",
						"          director_id,",
						"          year_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectColumns",
						"selectColumns select(mapColumn(",
						"          film_id,",
						"          runtime_minutes,",
						"          rating,",
						"          votes,",
						"          revenue_millions,",
						"          metascore,",
						"          director_id,",
						"          year_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectColumnsFinal",
						"selectColumnsFinal, targetFactFilm exists(selectColumnsFinal@film_id == targetFactFilm@film_id,",
						"     negate:true,",
						"     broadcast: 'auto')~> notExistsInsert",
						"selectColumnsFinal, targetFactFilm join(selectColumnsFinal@film_id == targetFactFilm@film_id",
						"     && selectColumnsFinal@year_id == targetFactFilm@year_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsUpdate",
						"existsUpdate alterRow(updateIf(notEquals(iifNull(selectColumnsFinal@runtime_minutes,-1,selectColumnsFinal@runtime_minutes),iifNull(targetFactFilm@runtime_minutes,-1,targetFactFilm@runtime_minutes))),",
						"     updateIf(notEquals(iifNull(selectColumnsFinal@rating,-1,selectColumnsFinal@rating),iifNull(targetFactFilm@rating,-1,targetFactFilm@rating))),",
						"     updateIf(notEquals(iifNull(selectColumnsFinal@votes,-1,selectColumnsFinal@votes),iifNull(targetFactFilm@votes,-1,targetFactFilm@votes))),",
						"     updateIf(notEquals(iifNull(selectColumnsFinal@revenue_millions,-1,selectColumnsFinal@revenue_millions),iifNull(targetFactFilm@revenue_millions,-1,targetFactFilm@revenue_millions))),",
						"     updateIf(notEquals(iifNull(selectColumnsFinal@metascore,-1,selectColumnsFinal@metascore),iifNull(targetFactFilm@metascore,-1,targetFactFilm@metascore)))) ~> updateIf",
						"notExistsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          runtime_minutes as double,",
						"          rating as double,",
						"          revenue_millions as double,",
						"          votes as integer,",
						"          metascore as integer,",
						"          film_id as integer,",
						"          director_id as integer,",
						"          year_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          runtime_minutes,",
						"          rating,",
						"          revenue_millions,",
						"          votes,",
						"          metascore,",
						"          film_id,",
						"          director_id,",
						"          year_id",
						"     )) ~> insertFactFilm",
						"updateIf sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          runtime_minutes as double,",
						"          rating as double,",
						"          revenue_millions as double,",
						"          votes as integer,",
						"          metascore as integer,",
						"          film_id as integer,",
						"          director_id as integer,",
						"          year_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['film_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          runtime_minutes = selectColumnsFinal@runtime_minutes,",
						"          rating = selectColumnsFinal@rating,",
						"          revenue_millions = selectColumnsFinal@revenue_millions,",
						"          votes = selectColumnsFinal@votes,",
						"          metascore = selectColumnsFinal@metascore,",
						"          film_id = targetFactFilm@film_id,",
						"          director_id = targetFactFilm@director_id,",
						"          year_id = targetFactFilm@year_id",
						"     )) ~> updateFactFilm"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/stg_film')]",
				"[concat(variables('factoryId'), '/datasets/map_director')]",
				"[concat(variables('factoryId'), '/datasets/map_year')]",
				"[concat(variables('factoryId'), '/datasets/map_film')]",
				"[concat(variables('factoryId'), '/datasets/fact_film')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_landing')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "blob_land_movies",
								"type": "DatasetReference"
							},
							"name": "bloblanding"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "move_db_landing",
								"type": "DatasetReference"
							},
							"name": "tomoviesdblanding"
						}
					],
					"transformations": [],
					"scriptLines": [
						"source(output(",
						"          Rank as string,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as string,",
						"          {Runtime (Minutes)} as string,",
						"          Rating as string,",
						"          Votes as string,",
						"          {Revenue (Millions)} as string,",
						"          Metascore as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> bloblanding",
						"bloblanding sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          Rank as integer,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as integer,",
						"          Runtime_Minutes as integer,",
						"          Rating as double,",
						"          Votes as integer,",
						"          Revenue_Millions as double,",
						"          Metascore as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     truncate:true,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          Rank,",
						"          Title,",
						"          Genre,",
						"          Description,",
						"          Director,",
						"          Actors,",
						"          Year,",
						"          Runtime_Minutes = {Runtime (Minutes)},",
						"          Rating,",
						"          Votes,",
						"          Revenue_Millions = {Revenue (Millions)},",
						"          Metascore",
						"     )) ~> tomoviesdblanding"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/blob_land_movies')]",
				"[concat(variables('factoryId'), '/datasets/move_db_landing')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_map_actor')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "move_db_landing",
								"type": "DatasetReference"
							},
							"name": "landMovies"
						},
						{
							"dataset": {
								"referenceName": "map_actor",
								"type": "DatasetReference"
							},
							"name": "targetMapActors"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "map_actor",
								"type": "DatasetReference"
							},
							"name": "loadintomapactors"
						},
						{
							"dataset": {
								"referenceName": "map_actor",
								"type": "DatasetReference"
							},
							"name": "insertMapActor"
						}
					],
					"transformations": [
						{
							"name": "splitActors"
						},
						{
							"name": "flattenActors"
						},
						{
							"name": "distinctActor"
						},
						{
							"name": "selectActors"
						},
						{
							"name": "trimActors"
						},
						{
							"name": "existsUpdate"
						},
						{
							"name": "updateIf"
						},
						{
							"name": "notExistsInsert"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Rank as integer,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as integer,",
						"          Runtime_Minutes as integer,",
						"          Rating as double,",
						"          Votes as integer,",
						"          Revenue_Millions as double,",
						"          Metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> landMovies",
						"source(output(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetMapActors",
						"landMovies derive(Actors = split(Actors, ',')) ~> splitActors",
						"splitActors foldDown(unroll(Actors),",
						"     mapColumn(",
						"          Rank,",
						"          Title,",
						"          Genre,",
						"          Description,",
						"          Director,",
						"          Actors,",
						"          Year,",
						"          {Runtime (Minutes)} = Runtime_Minutes,",
						"          Rating,",
						"          Votes,",
						"          {Revenue (Millions)} = Revenue_Millions,",
						"          Metascore",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flattenActors",
						"trimActors aggregate(groupBy(Actors),",
						"     each(match(name=='Rank'), $$ = first($$))) ~> distinctActor",
						"distinctActor select(mapColumn(",
						"          Actors",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectActors",
						"flattenActors derive(Actors = trim(Actors)) ~> trimActors",
						"selectActors, targetMapActors join(Actors == actor,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsUpdate",
						"existsUpdate alterRow(updateIf(notEquals(iifNull(Actors,'NULL',Actors),iifNull(actor,'NULL',actor)))) ~> updateIf",
						"selectActors, targetMapActors exists(Actors == actor,",
						"     negate:true,",
						"     broadcast: 'auto')~> notExistsInsert",
						"updateIf sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['actor_id'],",
						"     format: 'table',",
						"     batchSize: 100,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          actor = Actors,",
						"          actor_id",
						"     )) ~> loadintomapactors",
						"notExistsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          actor = Actors",
						"     )) ~> insertMapActor"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/move_db_landing')]",
				"[concat(variables('factoryId'), '/datasets/map_actor')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_map_dir')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "move_db_landing",
								"type": "DatasetReference"
							},
							"name": "landingmovies"
						},
						{
							"dataset": {
								"referenceName": "map_director",
								"type": "DatasetReference"
							},
							"name": "targertMapDirector"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "map_director",
								"type": "DatasetReference"
							},
							"name": "updateMapDir"
						},
						{
							"dataset": {
								"referenceName": "map_director",
								"type": "DatasetReference"
							},
							"name": "insertMapDir"
						}
					],
					"transformations": [
						{
							"name": "distinctDirector"
						},
						{
							"name": "existsUpdate"
						},
						{
							"name": "updateIf"
						},
						{
							"name": "notExistsInsert"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Rank as integer,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as integer,",
						"          Runtime_Minutes as integer,",
						"          Rating as double,",
						"          Votes as integer,",
						"          Revenue_Millions as double,",
						"          Metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> landingmovies",
						"source(output(",
						"          director_id as integer,",
						"          director as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targertMapDirector",
						"landingmovies aggregate(groupBy(Director),",
						"     each(match(name!='Director'), $$ = first($$))) ~> distinctDirector",
						"distinctDirector, targertMapDirector join(distinctDirector@Director == targertMapDirector@director,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsUpdate",
						"existsUpdate alterRow(updateIf(notEquals(iifNull(targertMapDirector@director,'NULL',targertMapDirector@director),iifNull(distinctDirector@Director,'NULL',distinctDirector@Director)))) ~> updateIf",
						"distinctDirector, targertMapDirector exists(distinctDirector@Director == targertMapDirector@director,",
						"     negate:true,",
						"     broadcast: 'auto')~> notExistsInsert",
						"updateIf sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          director_id as integer,",
						"          director as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['director_id'],",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          director = distinctDirector@Director,",
						"          director_id",
						"     )) ~> updateMapDir",
						"notExistsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          director_id as integer,",
						"          director as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          director = Director",
						"     )) ~> insertMapDir"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/move_db_landing')]",
				"[concat(variables('factoryId'), '/datasets/map_director')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_map_film')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "move_db_landing",
								"type": "DatasetReference"
							},
							"name": "landmovies"
						},
						{
							"dataset": {
								"referenceName": "map_film",
								"type": "DatasetReference"
							},
							"name": "targetMapFilm"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "map_film",
								"type": "DatasetReference"
							},
							"name": "insertMapFilm"
						},
						{
							"dataset": {
								"referenceName": "map_film",
								"type": "DatasetReference"
							},
							"name": "updateMapFilm"
						}
					],
					"transformations": [
						{
							"name": "selectTitleDirYear"
						},
						{
							"name": "notExistsInsert"
						},
						{
							"name": "existsUpdate"
						},
						{
							"name": "updateIf"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Rank as integer,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as integer,",
						"          Runtime_Minutes as integer,",
						"          Rating as double,",
						"          Votes as integer,",
						"          Revenue_Millions as double,",
						"          Metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> landmovies",
						"source(output(",
						"          film_id as integer,",
						"          title as string,",
						"          film_year as integer,",
						"          director as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetMapFilm",
						"landmovies select(mapColumn(",
						"          Title,",
						"          Director,",
						"          Year",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectTitleDirYear",
						"selectTitleDirYear, targetMapFilm exists(selectTitleDirYear@Title == targetMapFilm@title",
						"     && Year == film_year,",
						"     negate:true,",
						"     broadcast: 'auto')~> notExistsInsert",
						"selectTitleDirYear, targetMapFilm join(selectTitleDirYear@Title == targetMapFilm@title",
						"     && selectTitleDirYear@Director == targetMapFilm@director",
						"     && Year == film_year,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsUpdate",
						"existsUpdate alterRow(updateIf(notEquals(iifNull(selectTitleDirYear@Title,'NULL',selectTitleDirYear@Title),iifNull(targetMapFilm@title,'NULL',targetMapFilm@title))),",
						"     updateIf(notEquals(iifNull(selectTitleDirYear@Director,'NULL',selectTitleDirYear@Director),iifNull(targetMapFilm@director,'NULL',targetMapFilm@director))),",
						"     updateIf(notEquals(iifNull(Year,-1,Year),iifNull(film_year,-1,film_year)))) ~> updateIf",
						"notExistsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          film_id as integer,",
						"          title as string,",
						"          film_year as integer,",
						"          director as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          title = Title,",
						"          film_year = Year,",
						"          director = Director",
						"     )) ~> insertMapFilm",
						"updateIf sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          film_id as integer,",
						"          title as string,",
						"          film_year as integer,",
						"          director as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['film_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          film_id,",
						"          title = selectTitleDirYear@Title,",
						"          film_year = Year,",
						"          director = selectTitleDirYear@Director",
						"     )) ~> updateMapFilm"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/move_db_landing')]",
				"[concat(variables('factoryId'), '/datasets/map_film')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_map_genre')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "move_db_landing",
								"type": "DatasetReference"
							},
							"name": "landingmovies"
						},
						{
							"dataset": {
								"referenceName": "map_genre",
								"type": "DatasetReference"
							},
							"name": "targetMapGenre"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "map_genre",
								"type": "DatasetReference"
							},
							"name": "insertMapGenre"
						},
						{
							"dataset": {
								"referenceName": "map_genre",
								"type": "DatasetReference"
							},
							"name": "updateMapGenre"
						}
					],
					"transformations": [
						{
							"name": "splitGenre"
						},
						{
							"name": "flattenGenre"
						},
						{
							"name": "distinctGenre"
						},
						{
							"name": "selectGenre"
						},
						{
							"name": "trimGenre"
						},
						{
							"name": "notExistsInsert"
						},
						{
							"name": "existsUpdate"
						},
						{
							"name": "updateIf"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Rank as integer,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as integer,",
						"          Runtime_Minutes as integer,",
						"          Rating as double,",
						"          Votes as integer,",
						"          Revenue_Millions as double,",
						"          Metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> landingmovies",
						"source(output(",
						"          genre_id as integer,",
						"          genre as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetMapGenre",
						"landingmovies derive(Genre = split(Genre, ',')) ~> splitGenre",
						"splitGenre foldDown(unroll(Genre),",
						"     mapColumn(",
						"          Rank,",
						"          Title,",
						"          Genre,",
						"          Description,",
						"          Director,",
						"          Actors,",
						"          Year,",
						"          {Runtime (Minutes)} = Runtime_Minutes,",
						"          Rating,",
						"          Votes,",
						"          {Revenue (Millions)} = Revenue_Millions,",
						"          Metascore",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flattenGenre",
						"trimGenre aggregate(groupBy(Genre),",
						"     each(match(name=='Rank'), $$ = first($$))) ~> distinctGenre",
						"distinctGenre select(mapColumn(",
						"          Genre",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectGenre",
						"flattenGenre derive(Genre = trim(Genre)) ~> trimGenre",
						"selectGenre, targetMapGenre exists(selectGenre@Genre == targetMapGenre@genre,",
						"     negate:true,",
						"     broadcast: 'auto')~> notExistsInsert",
						"selectGenre, targetMapGenre join(selectGenre@Genre == targetMapGenre@genre,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsUpdate",
						"existsUpdate alterRow(updateIf(notEquals(iifNull(selectGenre@Genre,'NULL',selectGenre@Genre),iifNull(targetMapGenre@genre,'NULL',targetMapGenre@genre)))) ~> updateIf",
						"notExistsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          genre_id as integer,",
						"          genre as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          genre = Genre",
						"     )) ~> insertMapGenre",
						"updateIf sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          genre_id as integer,",
						"          genre as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['genre_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          genre_id,",
						"          genre = selectGenre@Genre",
						"     )) ~> updateMapGenre"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/move_db_landing')]",
				"[concat(variables('factoryId'), '/datasets/map_genre')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_map_year')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "move_db_landing",
								"type": "DatasetReference"
							},
							"name": "landingmovies"
						},
						{
							"dataset": {
								"referenceName": "map_year",
								"type": "DatasetReference"
							},
							"name": "targetMapYear"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "map_year",
								"type": "DatasetReference"
							},
							"name": "insertMapYear"
						},
						{
							"dataset": {
								"referenceName": "map_year",
								"type": "DatasetReference"
							},
							"name": "updateMapYear"
						}
					],
					"transformations": [
						{
							"name": "selectYear"
						},
						{
							"name": "distinctYear"
						},
						{
							"name": "notExistsInsert"
						},
						{
							"name": "existsUpdate"
						},
						{
							"name": "updateIf"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Rank as integer,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as integer,",
						"          Runtime_Minutes as integer,",
						"          Rating as double,",
						"          Votes as integer,",
						"          Revenue_Millions as double,",
						"          Metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> landingmovies",
						"source(output(",
						"          year_id as integer,",
						"          year as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetMapYear",
						"landingmovies select(mapColumn(",
						"          year = Year",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectYear",
						"selectYear aggregate(groupBy(year),",
						"     each(match(name!='year'), $$ = first($$))) ~> distinctYear",
						"distinctYear, targetMapYear exists(distinctYear@year == targetMapYear@year,",
						"     negate:true,",
						"     broadcast: 'auto')~> notExistsInsert",
						"distinctYear, targetMapYear join(distinctYear@year == targetMapYear@year,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsUpdate",
						"existsUpdate alterRow(updateIf(notEquals(iifNull(targetMapYear@year,-1,targetMapYear@year),iifNull(distinctYear@year,-1,distinctYear@year)))) ~> updateIf",
						"notExistsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          year_id as integer,",
						"          year as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          year",
						"     )) ~> insertMapYear",
						"updateIf sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          year_id as integer,",
						"          year as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['year_id'],",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          year_id,",
						"          year = distinctYear@year",
						"     )) ~> updateMapYear"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/move_db_landing')]",
				"[concat(variables('factoryId'), '/datasets/map_year')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_stg_actor')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "move_db_landing",
								"type": "DatasetReference"
							},
							"name": "landmovies"
						},
						{
							"dataset": {
								"referenceName": "map_actor",
								"type": "DatasetReference"
							},
							"name": "mapactor"
						},
						{
							"dataset": {
								"referenceName": "stg_actor",
								"type": "DatasetReference"
							},
							"name": "stgactor"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "stg_actor",
								"type": "DatasetReference"
							},
							"name": "insertstgactor"
						}
					],
					"transformations": [
						{
							"name": "splitActors"
						},
						{
							"name": "flattenActors"
						},
						{
							"name": "trimActors"
						},
						{
							"name": "joinMapActor"
						},
						{
							"name": "distinctActor"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Rank as integer,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as integer,",
						"          Runtime_Minutes as integer,",
						"          Rating as double,",
						"          Votes as integer,",
						"          Revenue_Millions as double,",
						"          Metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> landmovies",
						"source(output(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapactor",
						"source(output(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stgactor",
						"landmovies derive(Actors = split(Actors, ',')) ~> splitActors",
						"splitActors foldDown(unroll(Actors),",
						"     mapColumn(",
						"          Rank,",
						"          Title,",
						"          Genre,",
						"          Description,",
						"          Director,",
						"          Actors,",
						"          Year,",
						"          {Runtime (Minutes)} = Runtime_Minutes,",
						"          Rating,",
						"          Votes,",
						"          {Revenue (Millions)} = Revenue_Millions,",
						"          Metascore",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flattenActors",
						"flattenActors derive(Actors = trim(Actors)) ~> trimActors",
						"trimActors, mapactor join(Actors == actor,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinMapActor",
						"joinMapActor aggregate(groupBy(Actors),",
						"     each(match(name!='Actors'), $$ = first($$))) ~> distinctActor",
						"distinctActor sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     truncate:true,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          actor_id,",
						"          actor",
						"     )) ~> insertstgactor"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/move_db_landing')]",
				"[concat(variables('factoryId'), '/datasets/map_actor')]",
				"[concat(variables('factoryId'), '/datasets/stg_actor')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_stg_actor_film_assoc')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "move_db_landing",
								"type": "DatasetReference"
							},
							"name": "landingmovies"
						},
						{
							"dataset": {
								"referenceName": "map_actor",
								"type": "DatasetReference"
							},
							"name": "mapactor"
						},
						{
							"dataset": {
								"referenceName": "map_film",
								"type": "DatasetReference"
							},
							"name": "mapfilm"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "stg_actor_film_assoc",
								"type": "DatasetReference"
							},
							"name": "insertStgActorFilmAssoc"
						}
					],
					"transformations": [
						{
							"name": "actorsSplit"
						},
						{
							"name": "flattenActors"
						},
						{
							"name": "trimActors"
						},
						{
							"name": "joinMapFilm"
						},
						{
							"name": "selectActorsTitleYearDIr"
						},
						{
							"name": "joinMapActor"
						},
						{
							"name": "actorsFilmId"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Rank as integer,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as integer,",
						"          Runtime_Minutes as integer,",
						"          Rating as double,",
						"          Votes as integer,",
						"          Revenue_Millions as double,",
						"          Metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> landingmovies",
						"source(output(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapactor",
						"source(output(",
						"          film_id as integer,",
						"          title as string,",
						"          film_year as integer,",
						"          director as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapfilm",
						"landingmovies derive(Actors = split(Actors, ',')) ~> actorsSplit",
						"actorsSplit foldDown(unroll(Actors),",
						"     mapColumn(",
						"          Rank,",
						"          Title,",
						"          Genre,",
						"          Description,",
						"          Director,",
						"          Actors,",
						"          Year,",
						"          {Runtime (Minutes)} = Runtime_Minutes,",
						"          Rating,",
						"          Votes,",
						"          {Revenue (Millions)} = Revenue_Millions,",
						"          Metascore",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flattenActors",
						"flattenActors derive(Actors = trim(Actors)) ~> trimActors",
						"selectActorsTitleYearDIr, mapfilm join(selectActorsTitleYearDIr@Title == mapfilm@title",
						"     && selectActorsTitleYearDIr@Director == mapfilm@director,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinMapFilm",
						"trimActors select(mapColumn(",
						"          Actors,",
						"          Title,",
						"          Director,",
						"          Year",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> selectActorsTitleYearDIr",
						"actorsFilmId, mapactor join(Actors == actor,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'off')~> joinMapActor",
						"joinMapFilm select(mapColumn(",
						"          Actors,",
						"          film_id",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> actorsFilmId",
						"joinMapActor sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          stg_actor_film_id as integer,",
						"          actor_id as integer,",
						"          film_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     truncate:true,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          actor_id,",
						"          film_id",
						"     )) ~> insertStgActorFilmAssoc"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/move_db_landing')]",
				"[concat(variables('factoryId'), '/datasets/map_actor')]",
				"[concat(variables('factoryId'), '/datasets/map_film')]",
				"[concat(variables('factoryId'), '/datasets/stg_actor_film_assoc')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_stg_film')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "move_db_landing",
								"type": "DatasetReference"
							},
							"name": "landingmovie"
						},
						{
							"dataset": {
								"referenceName": "map_film",
								"type": "DatasetReference"
							},
							"name": "mapfilm"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "stg_film",
								"type": "DatasetReference"
							},
							"name": "insertStgFilm"
						}
					],
					"transformations": [
						{
							"name": "joinMapFilm"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Rank as integer,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as integer,",
						"          Runtime_Minutes as integer,",
						"          Rating as double,",
						"          Votes as integer,",
						"          Revenue_Millions as double,",
						"          Metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> landingmovie",
						"source(output(",
						"          film_id as integer,",
						"          title as string,",
						"          film_year as integer,",
						"          director as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapfilm",
						"landingmovie, mapfilm join(landingmovie@Title == mapfilm@title",
						"     && landingmovie@Director == mapfilm@director",
						"     && Year == film_year,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinMapFilm",
						"joinMapFilm sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          film_id as integer,",
						"          title as string,",
						"          description as string,",
						"          director as string,",
						"          film_year as integer,",
						"          runtime_minutes as integer,",
						"          rating as double,",
						"          votes as integer,",
						"          revenue_millions as double,",
						"          metascore as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     truncate:true,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          film_id,",
						"          title = landingmovie@Title,",
						"          description = Description,",
						"          director = landingmovie@Director,",
						"          film_year,",
						"          runtime_minutes = Runtime_Minutes,",
						"          rating = Rating,",
						"          votes = Votes,",
						"          revenue_millions = Revenue_Millions,",
						"          metascore = Metascore",
						"     )) ~> insertStgFilm"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/move_db_landing')]",
				"[concat(variables('factoryId'), '/datasets/map_film')]",
				"[concat(variables('factoryId'), '/datasets/stg_film')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_stg_genre')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "move_db_landing",
								"type": "DatasetReference"
							},
							"name": "landingmovies"
						},
						{
							"dataset": {
								"referenceName": "map_genre",
								"type": "DatasetReference"
							},
							"name": "mapgenre"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "stg_genre",
								"type": "DatasetReference"
							},
							"name": "sinkStgGenre"
						}
					],
					"transformations": [
						{
							"name": "splitGenre"
						},
						{
							"name": "flattenGenre"
						},
						{
							"name": "distinctGenre"
						},
						{
							"name": "selectGenre"
						},
						{
							"name": "trimGenre"
						},
						{
							"name": "joinMapGenre"
						},
						{
							"name": "selectGenreGenreId"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Rank as integer,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as integer,",
						"          Runtime_Minutes as integer,",
						"          Rating as double,",
						"          Votes as integer,",
						"          Revenue_Millions as double,",
						"          Metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> landingmovies",
						"source(output(",
						"          genre_id as integer,",
						"          genre as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapgenre",
						"landingmovies derive(Genre = split(Genre, ',')) ~> splitGenre",
						"splitGenre foldDown(unroll(Genre),",
						"     mapColumn(",
						"          Rank,",
						"          Title,",
						"          Genre,",
						"          Description,",
						"          Director,",
						"          Actors,",
						"          Year,",
						"          {Runtime (Minutes)} = Runtime_Minutes,",
						"          Rating,",
						"          Votes,",
						"          {Revenue (Millions)} = Revenue_Millions,",
						"          Metascore",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flattenGenre",
						"trimGenre aggregate(groupBy(Genre),",
						"     each(match(name=='Rank'), $$ = first($$))) ~> distinctGenre",
						"distinctGenre select(mapColumn(",
						"          Genre",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectGenre",
						"flattenGenre derive(Genre = trim(Genre)) ~> trimGenre",
						"selectGenre, mapgenre join(selectGenre@Genre == mapgenre@genre,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinMapGenre",
						"joinMapGenre select(mapColumn(",
						"          Genre = selectGenre@Genre,",
						"          genre_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectGenreGenreId",
						"selectGenreGenreId sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          genre_id as integer,",
						"          genre as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     truncate:true,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          genre_id,",
						"          genre = Genre",
						"     )) ~> sinkStgGenre"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/move_db_landing')]",
				"[concat(variables('factoryId'), '/datasets/map_genre')]",
				"[concat(variables('factoryId'), '/datasets/stg_genre')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_stg_genre_film_assoc')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "move_db_landing",
								"type": "DatasetReference"
							},
							"name": "landmovies"
						},
						{
							"dataset": {
								"referenceName": "map_genre",
								"type": "DatasetReference"
							},
							"name": "mapgenre"
						},
						{
							"dataset": {
								"referenceName": "map_film",
								"type": "DatasetReference"
							},
							"name": "mapfilm"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "stg_genre_film_assoc",
								"type": "DatasetReference"
							},
							"name": "sinkStgGenreFilmAssoc"
						}
					],
					"transformations": [
						{
							"name": "splitGenre"
						},
						{
							"name": "flattenGenre"
						},
						{
							"name": "trimGenre"
						},
						{
							"name": "joinMapFilm"
						},
						{
							"name": "joinMapGenre"
						},
						{
							"name": "selectFilmIdGenreId"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Rank as integer,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as integer,",
						"          Runtime_Minutes as integer,",
						"          Rating as double,",
						"          Votes as integer,",
						"          Revenue_Millions as double,",
						"          Metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> landmovies",
						"source(output(",
						"          genre_id as integer,",
						"          genre as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapgenre",
						"source(output(",
						"          film_id as integer,",
						"          title as string,",
						"          film_year as integer,",
						"          director as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapfilm",
						"landmovies derive(Genre = split(Genre, ',')) ~> splitGenre",
						"splitGenre foldDown(unroll(Genre),",
						"     mapColumn(",
						"          Rank,",
						"          Title,",
						"          Genre,",
						"          Description,",
						"          Director,",
						"          Actors,",
						"          Year,",
						"          {Runtime (Minutes)} = Runtime_Minutes,",
						"          Rating,",
						"          Votes,",
						"          {Revenue (Millions)} = Revenue_Millions,",
						"          Metascore",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flattenGenre",
						"flattenGenre derive(Genre = trim(Genre)) ~> trimGenre",
						"trimGenre, mapfilm join(flattenGenre@Director == mapfilm@director",
						"     && flattenGenre@Title == mapfilm@title,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinMapFilm",
						"joinMapFilm, mapgenre join(trimGenre@Genre == mapgenre@genre,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinMapGenre",
						"joinMapGenre select(mapColumn(",
						"          film_id,",
						"          genre_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectFilmIdGenreId",
						"selectFilmIdGenreId sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          stg_genre_film_id as integer,",
						"          genre_id as integer,",
						"          film_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     truncate:true,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          genre_id,",
						"          film_id",
						"     )) ~> sinkStgGenreFilmAssoc"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/move_db_landing')]",
				"[concat(variables('factoryId'), '/datasets/map_genre')]",
				"[concat(variables('factoryId'), '/datasets/map_film')]",
				"[concat(variables('factoryId'), '/datasets/stg_genre_film_assoc')]"
			]
		}
	]
}