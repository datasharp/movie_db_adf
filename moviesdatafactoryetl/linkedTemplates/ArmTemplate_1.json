{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "moviesdatafactoryetl"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/stg_genre_film_assoc')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureSqlDatabase1",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "02 stg and map"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "stg_genre_film_id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "genre_id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "film_id",
						"type": "int",
						"precision": 10
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "stg_genre_film_assoc"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/temp_actor_year_title_dir')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureSqlDatabase1",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "02 stg and map"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "Actors",
						"type": "nvarchar"
					},
					{
						"name": "Title",
						"type": "nvarchar"
					},
					{
						"name": "Director",
						"type": "nvarchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "temp_actor_title_year_dir"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_dim_actor')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "stg_actor",
								"type": "DatasetReference"
							},
							"name": "stgactor"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "dim_actor",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [],
					"scriptLines": [
						"source(output(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stgactor",
						"stgactor sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          actor_id,",
						"          actor",
						"     )) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_dim_dir')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "map_director",
								"type": "DatasetReference"
							},
							"name": "mapdir"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "dim_dir",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [],
					"scriptLines": [
						"source(output(",
						"          director_id as integer,",
						"          director as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapdir",
						"mapdir sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          director_id as integer,",
						"          director as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          director_id,",
						"          director",
						"     )) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_dim_genre_movie_assoc')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "stg_genre_film_assoc",
								"type": "DatasetReference"
							},
							"name": "stggenrefilmassoc"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "dim_genre_movie_assoc",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [],
					"scriptLines": [
						"source(output(",
						"          stg_genre_film_id as integer,",
						"          genre_id as integer,",
						"          film_id as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stggenrefilmassoc",
						"stggenrefilmassoc sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          dim_genre_movie_assoc_id as integer,",
						"          genre_id as integer,",
						"          film_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          dim_genre_movie_assoc_id = stg_genre_film_id,",
						"          genre_id,",
						"          film_id",
						"     )) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/stg_genre_film_assoc')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_dim_movie')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "stg_film",
								"type": "DatasetReference"
							},
							"name": "stgfilm"
						},
						{
							"dataset": {
								"referenceName": "map_film",
								"type": "DatasetReference"
							},
							"name": "mapfilm"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "dim_movie",
								"type": "DatasetReference"
							},
							"name": "sink2"
						}
					],
					"transformations": [
						{
							"name": "join1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          film_id as integer,",
						"          title as string,",
						"          description as string,",
						"          director as string,",
						"          film_year as integer,",
						"          runtime_minutes as integer,",
						"          rating as double,",
						"          votes as integer,",
						"          revenue_millions as double,",
						"          metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stgfilm",
						"source(output(",
						"          film_id as integer,",
						"          title as string,",
						"          film_year as integer,",
						"          director as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapfilm",
						"stgfilm, mapfilm join(stgfilm@film_id == mapfilm@film_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"join1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          film_id as integer,",
						"          title as string,",
						"          description as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> sink2"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_dim_movie_actor_assoc')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "stg_actor_film_assoc",
								"type": "DatasetReference"
							},
							"name": "stgactorfilmassoc"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "dim_actor_movie_assoc",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [],
					"scriptLines": [
						"source(output(",
						"          stg_actor_film_id as integer,",
						"          actor_id as integer,",
						"          film_id as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stgactorfilmassoc",
						"stgactorfilmassoc sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          dim_actor_movie_assoc_id as integer,",
						"          actor_id as integer,",
						"          film_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          dim_actor_movie_assoc_id = stg_actor_film_id,",
						"          actor_id,",
						"          film_id",
						"     )) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_dim_year')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "map_year",
								"type": "DatasetReference"
							},
							"name": "mapyear"
						},
						{
							"dataset": {
								"referenceName": "stg_film",
								"type": "DatasetReference"
							},
							"name": "stgfilm"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "dim_year",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "join1"
						},
						{
							"name": "select1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          year_id as integer,",
						"          year as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapyear",
						"source(output(",
						"          film_id as integer,",
						"          title as string,",
						"          description as string,",
						"          director as string,",
						"          film_year as integer,",
						"          runtime_minutes as integer,",
						"          rating as double,",
						"          votes as integer,",
						"          revenue_millions as double,",
						"          metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stgfilm",
						"stgfilm, mapyear join(film_year == year,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"join1 select(mapColumn(",
						"          year_id,",
						"          film_year",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          date_id as integer,",
						"          year as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          date_id = year_id,",
						"          year = film_year",
						"     )) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_fact_film')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "stg_film",
								"type": "DatasetReference"
							},
							"name": "stgfilm"
						},
						{
							"dataset": {
								"referenceName": "map_director",
								"type": "DatasetReference"
							},
							"name": "mapdirector"
						},
						{
							"dataset": {
								"referenceName": "map_year",
								"type": "DatasetReference"
							},
							"name": "mapyear"
						},
						{
							"dataset": {
								"referenceName": "map_film",
								"type": "DatasetReference"
							},
							"name": "mapfilm"
						},
						{
							"dataset": {
								"referenceName": "fact_film",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "fact_film",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "join1"
						},
						{
							"name": "join2"
						},
						{
							"name": "join3"
						},
						{
							"name": "select1"
						},
						{
							"name": "RemoveColumns1",
							"description": "Autogenerated by data preview actions"
						},
						{
							"name": "select2"
						}
					],
					"scriptLines": [
						"source(output(",
						"          film_id as integer,",
						"          title as string,",
						"          description as string,",
						"          director as string,",
						"          film_year as integer,",
						"          runtime_minutes as integer,",
						"          rating as double,",
						"          votes as integer,",
						"          revenue_millions as double,",
						"          metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stgfilm",
						"source(output(",
						"          director_id as integer,",
						"          director as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapdirector",
						"source(output(",
						"          year_id as integer,",
						"          year as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapyear",
						"source(output(",
						"          film_id as integer,",
						"          title as string,",
						"          film_year as integer,",
						"          director as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapfilm",
						"source(output(",
						"          runtime_minutes as double,",
						"          rating as double,",
						"          revenue_millions as double,",
						"          votes as integer,",
						"          metascore as integer,",
						"          film_id as integer,",
						"          director_id as integer,",
						"          year_id as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source1",
						"stgfilm, mapdirector join(stgfilm@director == mapdirector@director,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"join1, mapyear join(film_year == year,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"join2, mapfilm join(stgfilm@film_id == mapfilm@film_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join3",
						"join3 select(mapColumn(",
						"          film_id = stgfilm@film_id,",
						"          title = stgfilm@title,",
						"          description,",
						"          director = stgfilm@director,",
						"          film_year = stgfilm@film_year,",
						"          runtime_minutes,",
						"          rating,",
						"          votes,",
						"          revenue_millions,",
						"          metascore,",
						"          film_id = mapfilm@film_id,",
						"          director_id,",
						"          director = mapdirector@director,",
						"          year_id = mapfilm@film_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1 select(mapColumn(",
						"          film_id,",
						"          runtime_minutes,",
						"          rating,",
						"          votes,",
						"          revenue_millions,",
						"          metascore,",
						"          director_id,",
						"          year_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> RemoveColumns1",
						"RemoveColumns1 select(mapColumn(",
						"          film_id,",
						"          runtime_minutes,",
						"          rating,",
						"          votes,",
						"          revenue_millions,",
						"          metascore,",
						"          director_id,",
						"          year_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"select2 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          runtime_minutes as double,",
						"          rating as double,",
						"          revenue_millions as double,",
						"          votes as integer,",
						"          metascore as integer,",
						"          film_id as integer,",
						"          director_id as integer,",
						"          year_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 1000,",
						"     preSQLs:['TRUNCATE TABLE dbo.fact_film\\n'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          runtime_minutes,",
						"          rating,",
						"          revenue_millions,",
						"          votes,",
						"          metascore,",
						"          film_id,",
						"          director_id,",
						"          year_id",
						"     )) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_landing')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "blob_land_movies",
								"type": "DatasetReference"
							},
							"name": "bloblanding"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "move_db_landing",
								"type": "DatasetReference"
							},
							"name": "tomoviesdblanding"
						}
					],
					"transformations": [],
					"scriptLines": [
						"source(output(",
						"          Rank as string,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as string,",
						"          {Runtime (Minutes)} as string,",
						"          Rating as string,",
						"          Votes as string,",
						"          {Revenue (Millions)} as string,",
						"          Metascore as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> bloblanding",
						"bloblanding sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          Rank as integer,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as integer,",
						"          Runtime_Minutes as integer,",
						"          Rating as double,",
						"          Votes as integer,",
						"          Revenue_Millions as double,",
						"          Metascore as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     truncate:true,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          Rank,",
						"          Title,",
						"          Genre,",
						"          Description,",
						"          Director,",
						"          Actors,",
						"          Year,",
						"          Runtime_Minutes = {Runtime (Minutes)},",
						"          Rating,",
						"          Votes,",
						"          Revenue_Millions = {Revenue (Millions)},",
						"          Metascore",
						"     )) ~> tomoviesdblanding"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_map_actor')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "move_db_landing",
								"type": "DatasetReference"
							},
							"name": "landMovies"
						},
						{
							"dataset": {
								"referenceName": "map_actor",
								"type": "DatasetReference"
							},
							"name": "targetMapActors"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "map_actor",
								"type": "DatasetReference"
							},
							"name": "loadintomapactors"
						},
						{
							"dataset": {
								"referenceName": "map_actor",
								"type": "DatasetReference"
							},
							"name": "insertMapActor"
						}
					],
					"transformations": [
						{
							"name": "splitActors"
						},
						{
							"name": "flattenActors"
						},
						{
							"name": "aggOnActors"
						},
						{
							"name": "selectActors"
						},
						{
							"name": "cleanActors"
						},
						{
							"name": "existsUpdate"
						},
						{
							"name": "updateIfExists"
						},
						{
							"name": "notExistsInsert"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Rank as integer,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as integer,",
						"          Runtime_Minutes as integer,",
						"          Rating as double,",
						"          Votes as integer,",
						"          Revenue_Millions as double,",
						"          Metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> landMovies",
						"source(output(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetMapActors",
						"landMovies derive(Actors = split(Actors, ',')) ~> splitActors",
						"splitActors foldDown(unroll(Actors),",
						"     mapColumn(",
						"          Rank,",
						"          Title,",
						"          Genre,",
						"          Description,",
						"          Director,",
						"          Actors,",
						"          Year,",
						"          {Runtime (Minutes)} = Runtime_Minutes,",
						"          Rating,",
						"          Votes,",
						"          {Revenue (Millions)} = Revenue_Millions,",
						"          Metascore",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flattenActors",
						"cleanActors aggregate(groupBy(Actors),",
						"     each(match(name=='Rank'), $$ = first($$))) ~> aggOnActors",
						"aggOnActors select(mapColumn(",
						"          Actors",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectActors",
						"flattenActors derive(Actors = trim(Actors)) ~> cleanActors",
						"selectActors, targetMapActors join(Actors == actor,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsUpdate",
						"existsUpdate alterRow(updateIf(notEquals(iifNull(Actors,'NULL',Actors),iifNull(actor,'NULL',actor)))) ~> updateIfExists",
						"selectActors, targetMapActors exists(Actors == actor,",
						"     negate:true,",
						"     broadcast: 'auto')~> notExistsInsert",
						"updateIfExists sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['actor_id'],",
						"     format: 'table',",
						"     batchSize: 100,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          actor = Actors,",
						"          actor_id",
						"     )) ~> loadintomapactors",
						"notExistsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          actor = Actors",
						"     )) ~> insertMapActor"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_map_dir')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "move_db_landing",
								"type": "DatasetReference"
							},
							"name": "landingmovies"
						},
						{
							"dataset": {
								"referenceName": "map_film",
								"type": "DatasetReference"
							},
							"name": "mapfilm"
						},
						{
							"dataset": {
								"referenceName": "map_director",
								"type": "DatasetReference"
							},
							"name": "mapdirector"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "map_director",
								"type": "DatasetReference"
							},
							"name": "sinkMapDirector"
						},
						{
							"dataset": {
								"referenceName": "map_director",
								"type": "DatasetReference"
							},
							"name": "insertMapDirector"
						}
					],
					"transformations": [
						{
							"name": "joinMapFilm"
						},
						{
							"name": "distinctDirector"
						},
						{
							"name": "selectFilmIdDirector"
						},
						{
							"name": "existsUpdate"
						},
						{
							"name": "updateIf"
						},
						{
							"name": "notExistsInsert"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Rank as integer,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as integer,",
						"          Runtime_Minutes as integer,",
						"          Rating as double,",
						"          Votes as integer,",
						"          Revenue_Millions as double,",
						"          Metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> landingmovies",
						"source(output(",
						"          film_id as integer,",
						"          title as string,",
						"          film_year as integer,",
						"          director as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapfilm",
						"source(output(",
						"          director_id as integer,",
						"          director as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapdirector",
						"landingmovies, mapfilm join(landingmovies@Title == mapfilm@title",
						"     && Year == film_year",
						"     && landingmovies@Director == mapfilm@director,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinMapFilm",
						"selectFilmIdDirector aggregate(groupBy(director),",
						"     each(match(name!='director'), $$ = first($$))) ~> distinctDirector",
						"joinMapFilm select(mapColumn(",
						"          film_id,",
						"          director = landingmovies@Director",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectFilmIdDirector",
						"distinctDirector, mapdirector join(distinctDirector@director == mapdirector@director,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsUpdate",
						"existsUpdate alterRow(updateIf(notEquals(iifNull(mapdirector@director,'NULL',mapdirector@director),iifNull(distinctDirector@director,'NULL',distinctDirector@director)))) ~> updateIf",
						"distinctDirector, mapdirector exists(distinctDirector@director == mapdirector@director,",
						"     negate:true,",
						"     broadcast: 'auto')~> notExistsInsert",
						"updateIf sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          director_id as integer,",
						"          director as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['director_id'],",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          director = distinctDirector@director,",
						"          director_id",
						"     )) ~> sinkMapDirector",
						"notExistsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          director_id as integer,",
						"          director as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          director",
						"     )) ~> insertMapDirector"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_map_film')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "move_db_landing",
								"type": "DatasetReference"
							},
							"name": "landmovies"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "map_film",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "select1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Rank as integer,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as integer,",
						"          Runtime_Minutes as integer,",
						"          Rating as double,",
						"          Votes as integer,",
						"          Revenue_Millions as double,",
						"          Metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> landmovies",
						"landmovies select(mapColumn(",
						"          Title,",
						"          Director,",
						"          Year",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          film_id as integer,",
						"          title as string,",
						"          film_year as integer,",
						"          director as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          title = Title,",
						"          film_year = Year,",
						"          director = Director",
						"     )) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_map_genre')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "blob_land_movies",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "map_genre",
								"type": "DatasetReference"
							},
							"name": "loadintomapgenre"
						}
					],
					"transformations": [
						{
							"name": "derivedColumn1"
						},
						{
							"name": "flatten1"
						},
						{
							"name": "aggregate1"
						},
						{
							"name": "select1"
						},
						{
							"name": "cleanGenre"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Rank as string,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as string,",
						"          {Runtime (Minutes)} as string,",
						"          Rating as string,",
						"          Votes as string,",
						"          {Revenue (Millions)} as string,",
						"          Metascore as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> source1",
						"source1 derive(Genre = split(Genre, ',')) ~> derivedColumn1",
						"derivedColumn1 foldDown(unroll(Genre),",
						"     mapColumn(",
						"          Rank,",
						"          Title,",
						"          Genre,",
						"          Description,",
						"          Director,",
						"          Actors,",
						"          Year,",
						"          {Runtime (Minutes)},",
						"          Rating,",
						"          Votes,",
						"          {Revenue (Millions)},",
						"          Metascore",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flatten1",
						"cleanGenre aggregate(groupBy(Genre),",
						"     each(match(name=='Rank'), $$ = first($$))) ~> aggregate1",
						"aggregate1 select(mapColumn(",
						"          Genre",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"flatten1 derive(Genre = trim(Genre)) ~> cleanGenre",
						"select1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          genre_id as integer,",
						"          genre as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          genre = Genre",
						"     )) ~> loadintomapgenre"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_map_year')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "move_db_landing",
								"type": "DatasetReference"
							},
							"name": "landingmovies"
						},
						{
							"dataset": {
								"referenceName": "map_year",
								"type": "DatasetReference"
							},
							"name": "targetMapYear"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "map_year",
								"type": "DatasetReference"
							},
							"name": "insertMapYear"
						},
						{
							"dataset": {
								"referenceName": "map_year",
								"type": "DatasetReference"
							},
							"name": "updateMapYear"
						}
					],
					"transformations": [
						{
							"name": "selectYear"
						},
						{
							"name": "distinctYear"
						},
						{
							"name": "notExistsInsert"
						},
						{
							"name": "existsUpdate"
						},
						{
							"name": "updateIf"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Rank as integer,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as integer,",
						"          Runtime_Minutes as integer,",
						"          Rating as double,",
						"          Votes as integer,",
						"          Revenue_Millions as double,",
						"          Metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> landingmovies",
						"source(output(",
						"          year_id as integer,",
						"          year as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetMapYear",
						"landingmovies select(mapColumn(",
						"          year = Year",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectYear",
						"selectYear aggregate(groupBy(year),",
						"     each(match(name!='year'), $$ = first($$))) ~> distinctYear",
						"distinctYear, targetMapYear exists(distinctYear@year == targetMapYear@year,",
						"     negate:true,",
						"     broadcast: 'auto')~> notExistsInsert",
						"distinctYear, targetMapYear join(distinctYear@year == targetMapYear@year,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsUpdate",
						"existsUpdate alterRow(updateIf(notEquals(iifNull(targetMapYear@year,-1,targetMapYear@year),iifNull(distinctYear@year,-1,distinctYear@year)))) ~> updateIf",
						"notExistsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          year_id as integer,",
						"          year as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          year",
						"     )) ~> insertMapYear",
						"updateIf sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          year_id as integer,",
						"          year as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['year_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          year_id,",
						"          year = distinctYear@year",
						"     )) ~> updateMapYear"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_stg_actor')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "blob_land_movies",
								"type": "DatasetReference"
							},
							"name": "source1"
						},
						{
							"dataset": {
								"referenceName": "map_actor",
								"type": "DatasetReference"
							},
							"name": "mapactor"
						},
						{
							"dataset": {
								"referenceName": "stg_actor",
								"type": "DatasetReference"
							},
							"name": "stgactor"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "stg_actor",
								"type": "DatasetReference"
							},
							"name": "insertstgactor"
						},
						{
							"dataset": {
								"referenceName": "stg_actor",
								"type": "DatasetReference"
							},
							"name": "updatestgactor"
						}
					],
					"transformations": [
						{
							"name": "derivedColumn1"
						},
						{
							"name": "flatten1"
						},
						{
							"name": "cleanActors"
						},
						{
							"name": "join1"
						},
						{
							"name": "aggregate1"
						},
						{
							"name": "select1"
						},
						{
							"name": "notexistsinsert"
						},
						{
							"name": "updateif"
						},
						{
							"name": "existsupdate"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Rank as string,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as string,",
						"          {Runtime (Minutes)} as string,",
						"          Rating as string,",
						"          Votes as string,",
						"          {Revenue (Millions)} as string,",
						"          Metascore as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> source1",
						"source(output(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapactor",
						"source(output(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stgactor",
						"source1 derive(Actors = split(Actors, ',')) ~> derivedColumn1",
						"derivedColumn1 foldDown(unroll(Actors),",
						"     mapColumn(",
						"          Rank,",
						"          Title,",
						"          Genre,",
						"          Description,",
						"          Director,",
						"          Actors,",
						"          Year,",
						"          {Runtime (Minutes)},",
						"          Rating,",
						"          Votes,",
						"          {Revenue (Millions)},",
						"          Metascore",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flatten1",
						"flatten1 derive(Actors = trim(Actors)) ~> cleanActors",
						"cleanActors, mapactor join(Actors == actor,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"join1 aggregate(groupBy(Actors),",
						"     each(match(name!='Actors'), $$ = first($$))) ~> aggregate1",
						"aggregate1 select(mapColumn(",
						"          actor_id,",
						"          actor",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1, stgactor exists(select1@actor_id == stgactor@actor_id,",
						"     negate:true,",
						"     broadcast: 'auto')~> notexistsinsert",
						"existsupdate alterRow(updateIf(notEquals(iifNull(stgactor@actor,'NULL',stgactor@actor),iifNull(select1@actor,'NULL',select1@actor)))) ~> updateif",
						"select1, stgactor join(select1@actor_id == stgactor@actor_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsupdate",
						"notexistsinsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> insertstgactor",
						"updateif sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['actor_id'],",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          actor_id = select1@actor_id,",
						"          actor = select1@actor",
						"     )) ~> updatestgactor"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_stg_actor_film_assoc')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "blob_land_movies",
								"type": "DatasetReference"
							},
							"name": "source1"
						},
						{
							"dataset": {
								"referenceName": "map_actor",
								"type": "DatasetReference"
							},
							"name": "mapactor"
						},
						{
							"dataset": {
								"referenceName": "map_film",
								"type": "DatasetReference"
							},
							"name": "mapfilm"
						},
						{
							"dataset": {
								"referenceName": "stg_actor_film_assoc",
								"type": "DatasetReference"
							},
							"name": "stgactorfilmassoc"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "stg_actor_film_assoc",
								"type": "DatasetReference"
							},
							"name": "insertintostgfilmactorassoc"
						},
						{
							"dataset": {
								"referenceName": "stg_actor_film_assoc",
								"type": "DatasetReference"
							},
							"name": "deletefromstgfilmactorassoc"
						}
					],
					"transformations": [
						{
							"name": "derivedColumn1"
						},
						{
							"name": "flatten1"
						},
						{
							"name": "cleanActors"
						},
						{
							"name": "join1"
						},
						{
							"name": "select2"
						},
						{
							"name": "join2"
						},
						{
							"name": "select3"
						},
						{
							"name": "select4"
						},
						{
							"name": "insertwherenotexists"
						},
						{
							"name": "deletenotexists"
						},
						{
							"name": "delete"
						},
						{
							"name": "select5"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Rank as string,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as string,",
						"          {Runtime (Minutes)} as string,",
						"          Rating as string,",
						"          Votes as string,",
						"          {Revenue (Millions)} as string,",
						"          Metascore as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> source1",
						"source(output(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapactor",
						"source(output(",
						"          film_id as integer,",
						"          title as string,",
						"          film_year as integer,",
						"          director as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapfilm",
						"source(output(",
						"          stg_actor_film_id as integer,",
						"          actor_id as integer,",
						"          film_id as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stgactorfilmassoc",
						"source1 derive(Actors = split(Actors, ',')) ~> derivedColumn1",
						"derivedColumn1 foldDown(unroll(Actors),",
						"     mapColumn(",
						"          Rank,",
						"          Title,",
						"          Genre,",
						"          Description,",
						"          Director,",
						"          Actors,",
						"          Year,",
						"          {Runtime (Minutes)},",
						"          Rating,",
						"          Votes,",
						"          {Revenue (Millions)},",
						"          Metascore",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flatten1",
						"flatten1 derive(Actors = trim(Actors)) ~> cleanActors",
						"select2, mapfilm join(select2@Title == mapfilm@title",
						"     && select2@Director == mapfilm@director,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"cleanActors select(mapColumn(",
						"          Actors,",
						"          Title,",
						"          Director,",
						"          Year",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> select2",
						"select3, mapactor join(Actors == actor,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'off')~> join2",
						"join1 select(mapColumn(",
						"          Actors,",
						"          film_id",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> select3",
						"join2 select(mapColumn(",
						"          film_id,",
						"          actor_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select4",
						"select4, select5 exists(select4@film_id == select5@film_id",
						"     && select4@actor_id == select5@actor_id,",
						"     negate:true,",
						"     broadcast: 'auto')~> insertwherenotexists",
						"select5, select4 exists(select4@film_id == select5@film_id",
						"     && select4@actor_id == select5@actor_id,",
						"     negate:true,",
						"     broadcast: 'auto')~> deletenotexists",
						"deletenotexists alterRow(deleteIf(true())) ~> delete",
						"stgactorfilmassoc select(mapColumn(",
						"          actor_id,",
						"          film_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select5",
						"insertwherenotexists sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          stg_actor_film_id as integer,",
						"          actor_id as integer,",
						"          film_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          actor_id,",
						"          film_id",
						"     )) ~> insertintostgfilmactorassoc",
						"delete sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          stg_actor_film_id as integer,",
						"          actor_id as integer,",
						"          film_id as integer",
						"     ),",
						"     deletable:true,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:false,",
						"     keys:['actor_id'],",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> deletefromstgfilmactorassoc"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_stg_film')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "move_db_landing",
								"type": "DatasetReference"
							},
							"name": "landingmovie"
						},
						{
							"dataset": {
								"referenceName": "map_film",
								"type": "DatasetReference"
							},
							"name": "mapfilm"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "stg_film",
								"type": "DatasetReference"
							},
							"name": "loadintostgfilm"
						}
					],
					"transformations": [
						{
							"name": "join4"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Rank as integer,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as integer,",
						"          Runtime_Minutes as integer,",
						"          Rating as double,",
						"          Votes as integer,",
						"          Revenue_Millions as double,",
						"          Metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> landingmovie",
						"source(output(",
						"          film_id as integer,",
						"          title as string,",
						"          film_year as integer,",
						"          director as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapfilm",
						"mapfilm, landingmovie join(mapfilm@title == landingmovie@Title",
						"     && film_year == Year",
						"     && mapfilm@director == landingmovie@Director,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join4",
						"join4 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          film_id as integer,",
						"          title as string,",
						"          description as string,",
						"          director as string,",
						"          film_year as integer,",
						"          runtime_minutes as integer,",
						"          rating as double,",
						"          votes as integer,",
						"          revenue_millions as double,",
						"          metascore as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          film_id,",
						"          title = landingmovie@Title,",
						"          description = Description,",
						"          director = landingmovie@Director,",
						"          film_year,",
						"          runtime_minutes = Runtime_Minutes,",
						"          rating = Rating,",
						"          votes = Votes,",
						"          revenue_millions = Revenue_Millions,",
						"          metascore = Metascore",
						"     )) ~> loadintostgfilm"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_stg_genre')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "move_db_landing",
								"type": "DatasetReference"
							},
							"name": "landingmovies"
						},
						{
							"dataset": {
								"referenceName": "map_genre",
								"type": "DatasetReference"
							},
							"name": "mapgenre"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "stg_genre",
								"type": "DatasetReference"
							},
							"name": "sinkStgGenre"
						}
					],
					"transformations": [
						{
							"name": "splitGenre"
						},
						{
							"name": "flattenGenre"
						},
						{
							"name": "distinctGenre"
						},
						{
							"name": "selectGenre"
						},
						{
							"name": "trimGenre"
						},
						{
							"name": "joinMapGenre"
						},
						{
							"name": "selectGenreGenreId"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Rank as integer,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as integer,",
						"          Runtime_Minutes as integer,",
						"          Rating as double,",
						"          Votes as integer,",
						"          Revenue_Millions as double,",
						"          Metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> landingmovies",
						"source(output(",
						"          genre_id as integer,",
						"          genre as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapgenre",
						"landingmovies derive(Genre = split(Genre, ',')) ~> splitGenre",
						"splitGenre foldDown(unroll(Genre),",
						"     mapColumn(",
						"          Rank,",
						"          Title,",
						"          Genre,",
						"          Description,",
						"          Director,",
						"          Actors,",
						"          Year,",
						"          {Runtime (Minutes)} = Runtime_Minutes,",
						"          Rating,",
						"          Votes,",
						"          {Revenue (Millions)} = Revenue_Millions,",
						"          Metascore",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flattenGenre",
						"trimGenre aggregate(groupBy(Genre),",
						"     each(match(name=='Rank'), $$ = first($$))) ~> distinctGenre",
						"distinctGenre select(mapColumn(",
						"          Genre",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectGenre",
						"flattenGenre derive(Genre = trim(Genre)) ~> trimGenre",
						"selectGenre, mapgenre join(selectGenre@Genre == mapgenre@genre,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinMapGenre",
						"joinMapGenre select(mapColumn(",
						"          Genre = selectGenre@Genre,",
						"          genre_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectGenreGenreId",
						"selectGenreGenreId sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          genre_id as integer,",
						"          genre as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     truncate:true,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          genre_id,",
						"          genre = Genre",
						"     )) ~> sinkStgGenre"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_stg_genre_film_assoc')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "move_db_landing",
								"type": "DatasetReference"
							},
							"name": "landmovies"
						},
						{
							"dataset": {
								"referenceName": "map_genre",
								"type": "DatasetReference"
							},
							"name": "mapgenre"
						},
						{
							"dataset": {
								"referenceName": "map_film",
								"type": "DatasetReference"
							},
							"name": "mapfilm"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "stg_genre_film_assoc",
								"type": "DatasetReference"
							},
							"name": "sinkStgGenreFilmAssoc"
						}
					],
					"transformations": [
						{
							"name": "splitGenre"
						},
						{
							"name": "flattenGenre"
						},
						{
							"name": "trimGenre"
						},
						{
							"name": "joinMapFilm"
						},
						{
							"name": "joinMapGenre"
						},
						{
							"name": "selectFilmIdGenreId"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Rank as integer,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as integer,",
						"          Runtime_Minutes as integer,",
						"          Rating as double,",
						"          Votes as integer,",
						"          Revenue_Millions as double,",
						"          Metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> landmovies",
						"source(output(",
						"          genre_id as integer,",
						"          genre as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapgenre",
						"source(output(",
						"          film_id as integer,",
						"          title as string,",
						"          film_year as integer,",
						"          director as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapfilm",
						"landmovies derive(Genre = split(Genre, ',')) ~> splitGenre",
						"splitGenre foldDown(unroll(Genre),",
						"     mapColumn(",
						"          Rank,",
						"          Title,",
						"          Genre,",
						"          Description,",
						"          Director,",
						"          Actors,",
						"          Year,",
						"          {Runtime (Minutes)} = Runtime_Minutes,",
						"          Rating,",
						"          Votes,",
						"          {Revenue (Millions)} = Revenue_Millions,",
						"          Metascore",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flattenGenre",
						"flattenGenre derive(Genre = trim(Genre)) ~> trimGenre",
						"trimGenre, mapfilm join(flattenGenre@Director == mapfilm@director",
						"     && flattenGenre@Title == mapfilm@title,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinMapFilm",
						"joinMapFilm, mapgenre join(trimGenre@Genre == mapgenre@genre,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinMapGenre",
						"joinMapGenre select(mapColumn(",
						"          film_id,",
						"          genre_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectFilmIdGenreId",
						"selectFilmIdGenreId sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          stg_genre_film_id as integer,",
						"          genre_id as integer,",
						"          film_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     truncate:true,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          genre_id,",
						"          film_id",
						"     )) ~> sinkStgGenreFilmAssoc"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/stg_genre_film_assoc')]"
			]
		}
	]
}