{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "moviesdatafactoryetl"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/stg_genre')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureSqlDatabase1",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "02 stg and map"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "genre_id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "genre",
						"type": "nvarchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "stg_genre"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/stg_genre_film_assoc')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureSqlDatabase1",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "02 stg and map"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "stg_genre_film_id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "genre_id",
						"type": "int",
						"precision": 10
					},
					{
						"name": "film_id",
						"type": "int",
						"precision": 10
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "stg_genre_film_assoc"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/temp_actor_year_title_dir')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureSqlDatabase1",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "02 stg and map"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [
					{
						"name": "Actors",
						"type": "nvarchar"
					},
					{
						"name": "Title",
						"type": "nvarchar"
					},
					{
						"name": "Director",
						"type": "nvarchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "temp_actor_title_year_dir"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_dim_actor')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "stg_actor",
								"type": "DatasetReference"
							},
							"name": "stgactor"
						},
						{
							"dataset": {
								"referenceName": "dim_actor",
								"type": "DatasetReference"
							},
							"name": "targetDimActor"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "dim_actor",
								"type": "DatasetReference"
							},
							"name": "updateDimActor"
						},
						{
							"dataset": {
								"referenceName": "dim_actor",
								"type": "DatasetReference"
							},
							"name": "insertDimActor"
						}
					],
					"transformations": [
						{
							"name": "existsUpdate"
						},
						{
							"name": "notExistsInsert"
						},
						{
							"name": "updateif"
						}
					],
					"scriptLines": [
						"source(output(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stgactor",
						"source(output(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetDimActor",
						"stgactor, targetDimActor join(stgactor@actor_id == targetDimActor@actor_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsUpdate",
						"stgactor, targetDimActor exists(stgactor@actor == targetDimActor@actor,",
						"     negate:true,",
						"     broadcast: 'auto')~> notExistsInsert",
						"existsUpdate alterRow(updateIf(notEquals(iifNull(stgactor@actor,'NULL',stgactor@actor),iifNull(targetDimActor@actor,'NULL',targetDimActor@actor)))) ~> updateif",
						"updateif sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['actor_id'],",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          actor_id = stgactor@actor_id,",
						"          actor = stgactor@actor",
						"     )) ~> updateDimActor",
						"notExistsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          actor_id,",
						"          actor",
						"     )) ~> insertDimActor"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_dim_actor_movie_assoc')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "stg_actor_film_assoc",
								"type": "DatasetReference"
							},
							"name": "stgactorfilmassoc"
						},
						{
							"dataset": {
								"referenceName": "dim_actor_movie_assoc",
								"type": "DatasetReference"
							},
							"name": "targetdimactorfilmassoc"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "dim_actor_movie_assoc",
								"type": "DatasetReference"
							},
							"name": "sinkDimActorFilmAssoc"
						},
						{
							"dataset": {
								"referenceName": "dim_actor_movie_assoc",
								"type": "DatasetReference"
							},
							"name": "updateDimActorFilmAssoc"
						}
					],
					"transformations": [
						{
							"name": "notExistsInsert"
						},
						{
							"name": "existsUpdate"
						},
						{
							"name": "updateIf"
						}
					],
					"scriptLines": [
						"source(output(",
						"          stg_actor_film_id as integer,",
						"          actor_id as integer,",
						"          film_id as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stgactorfilmassoc",
						"source(output(",
						"          dim_actor_movie_assoc_id as integer,",
						"          actor_id as integer,",
						"          film_id as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetdimactorfilmassoc",
						"stgactorfilmassoc, targetdimactorfilmassoc exists(stg_actor_film_id == dim_actor_movie_assoc_id,",
						"     negate:true,",
						"     broadcast: 'auto')~> notExistsInsert",
						"stgactorfilmassoc, targetdimactorfilmassoc join(stg_actor_film_id == dim_actor_movie_assoc_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsUpdate",
						"existsUpdate alterRow(updateIf(notEquals(iifNull(stgactorfilmassoc@actor_id,-1,stgactorfilmassoc@actor_id),iifNull(targetdimactorfilmassoc@actor_id,-1,targetdimactorfilmassoc@actor_id)))) ~> updateIf",
						"notExistsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          dim_actor_movie_assoc_id as integer,",
						"          actor_id as integer,",
						"          film_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          dim_actor_movie_assoc_id = stg_actor_film_id,",
						"          actor_id,",
						"          film_id",
						"     )) ~> sinkDimActorFilmAssoc",
						"updateIf sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          dim_actor_movie_assoc_id as integer,",
						"          actor_id as integer,",
						"          film_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['dim_actor_movie_assoc_id'],",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          dim_actor_movie_assoc_id,",
						"          actor_id = stgactorfilmassoc@actor_id,",
						"          film_id = stgactorfilmassoc@film_id",
						"     )) ~> updateDimActorFilmAssoc"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_dim_dir')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "map_director",
								"type": "DatasetReference"
							},
							"name": "mapdir"
						},
						{
							"dataset": {
								"referenceName": "dim_dir",
								"type": "DatasetReference"
							},
							"name": "targetDimDir"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "dim_dir",
								"type": "DatasetReference"
							},
							"name": "insertDimDir"
						},
						{
							"dataset": {
								"referenceName": "dim_dir",
								"type": "DatasetReference"
							},
							"name": "updateDimDir"
						}
					],
					"transformations": [
						{
							"name": "notExistsInsert"
						},
						{
							"name": "existsUpdate"
						},
						{
							"name": "updateIf"
						}
					],
					"scriptLines": [
						"source(output(",
						"          director_id as integer,",
						"          director as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapdir",
						"source(output(",
						"          director_id as integer,",
						"          director as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetDimDir",
						"mapdir, targetDimDir exists(mapdir@director_id == targetDimDir@director_id,",
						"     negate:true,",
						"     broadcast: 'auto')~> notExistsInsert",
						"mapdir, targetDimDir join(mapdir@director_id == targetDimDir@director_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsUpdate",
						"existsUpdate alterRow(updateIf(notEquals(iifNull(mapdir@director,'NULL',mapdir@director),iifNull(targetDimDir@director,'NULL',targetDimDir@director)))) ~> updateIf",
						"notExistsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          director_id as integer,",
						"          director as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          director_id,",
						"          director",
						"     )) ~> insertDimDir",
						"updateIf sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          director_id as integer,",
						"          director as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['director_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> updateDimDir"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_dim_genre')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "stg_genre",
								"type": "DatasetReference"
							},
							"name": "stggenre"
						},
						{
							"dataset": {
								"referenceName": "dim_genre",
								"type": "DatasetReference"
							},
							"name": "targetdimgenre"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "dim_genre",
								"type": "DatasetReference"
							},
							"name": "insertDimGenre"
						},
						{
							"dataset": {
								"referenceName": "dim_genre",
								"type": "DatasetReference"
							},
							"name": "updateDimGenre"
						}
					],
					"transformations": [
						{
							"name": "notExistsInsert"
						},
						{
							"name": "existsUpdate"
						},
						{
							"name": "updateIf"
						}
					],
					"scriptLines": [
						"source(output(",
						"          genre_id as integer,",
						"          genre as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stggenre",
						"source(output(",
						"          genre_id as integer,",
						"          genre as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetdimgenre",
						"stggenre, targetdimgenre exists(stggenre@genre_id == targetdimgenre@genre_id,",
						"     negate:true,",
						"     broadcast: 'auto')~> notExistsInsert",
						"stggenre, targetdimgenre join(stggenre@genre_id == targetdimgenre@genre_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsUpdate",
						"existsUpdate alterRow(updateIf(notEquals(iifNull(stggenre@genre,'NULL',stggenre@genre),iifNull(targetdimgenre@genre,'NULL',targetdimgenre@genre)))) ~> updateIf",
						"notExistsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          genre_id as integer,",
						"          genre as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          genre_id,",
						"          genre",
						"     )) ~> insertDimGenre",
						"updateIf sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          genre_id as integer,",
						"          genre as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['genre_id'],",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          genre_id = stggenre@genre_id,",
						"          genre = stggenre@genre",
						"     )) ~> updateDimGenre"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/stg_genre')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_dim_genre_movie_assoc')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "stg_genre_film_assoc",
								"type": "DatasetReference"
							},
							"name": "stggenrefilmassoc"
						},
						{
							"dataset": {
								"referenceName": "dim_genre_movie_assoc",
								"type": "DatasetReference"
							},
							"name": "targetDimGenreFilmAssoc"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "dim_genre_movie_assoc",
								"type": "DatasetReference"
							},
							"name": "insertDimGenreFilmAssoc"
						},
						{
							"dataset": {
								"referenceName": "dim_genre_movie_assoc",
								"type": "DatasetReference"
							},
							"name": "updateDimGenreFilmAssoc"
						}
					],
					"transformations": [
						{
							"name": "notExistsInsert"
						},
						{
							"name": "existsUpdate"
						},
						{
							"name": "updateIf"
						}
					],
					"scriptLines": [
						"source(output(",
						"          stg_genre_film_id as integer,",
						"          genre_id as integer,",
						"          film_id as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stggenrefilmassoc",
						"source(output(",
						"          dim_genre_movie_assoc_id as integer,",
						"          genre_id as integer,",
						"          film_id as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetDimGenreFilmAssoc",
						"stggenrefilmassoc, targetDimGenreFilmAssoc exists(stg_genre_film_id == dim_genre_movie_assoc_id,",
						"     negate:true,",
						"     broadcast: 'auto')~> notExistsInsert",
						"stggenrefilmassoc, targetDimGenreFilmAssoc join(stg_genre_film_id == dim_genre_movie_assoc_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsUpdate",
						"existsUpdate alterRow(updateIf(notEquals(iifNull(stggenrefilmassoc@genre_id,-1,stggenrefilmassoc@genre_id),iifNull(targetDimGenreFilmAssoc@genre_id,-1,targetDimGenreFilmAssoc@genre_id))),",
						"     updateIf(notEquals(iifNull(stggenrefilmassoc@film_id,-1,stggenrefilmassoc@film_id),iifNull(targetDimGenreFilmAssoc@film_id,-1,targetDimGenreFilmAssoc@film_id)))) ~> updateIf",
						"notExistsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          dim_genre_movie_assoc_id as integer,",
						"          genre_id as integer,",
						"          film_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          dim_genre_movie_assoc_id = stg_genre_film_id,",
						"          genre_id,",
						"          film_id",
						"     )) ~> insertDimGenreFilmAssoc",
						"updateIf sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          dim_genre_movie_assoc_id as integer,",
						"          genre_id as integer,",
						"          film_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['dim_genre_movie_assoc_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          dim_genre_movie_assoc_id,",
						"          genre_id = stggenrefilmassoc@genre_id,",
						"          film_id = stggenrefilmassoc@film_id",
						"     )) ~> updateDimGenreFilmAssoc"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/stg_genre_film_assoc')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_dim_movie')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "stg_film",
								"type": "DatasetReference"
							},
							"name": "stgfilm"
						},
						{
							"dataset": {
								"referenceName": "dim_movie",
								"type": "DatasetReference"
							},
							"name": "targetDimMovie"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "dim_movie",
								"type": "DatasetReference"
							},
							"name": "updateDimMovie"
						},
						{
							"dataset": {
								"referenceName": "dim_movie",
								"type": "DatasetReference"
							},
							"name": "insertDimMovie"
						}
					],
					"transformations": [
						{
							"name": "existsUpdate"
						},
						{
							"name": "notExistsInsert"
						},
						{
							"name": "updateIf"
						}
					],
					"scriptLines": [
						"source(output(",
						"          film_id as integer,",
						"          title as string,",
						"          description as string,",
						"          director as string,",
						"          film_year as integer,",
						"          runtime_minutes as integer,",
						"          rating as double,",
						"          votes as integer,",
						"          revenue_millions as double,",
						"          metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stgfilm",
						"source(output(",
						"          film_id as integer,",
						"          title as string,",
						"          description as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetDimMovie",
						"stgfilm, targetDimMovie join(stgfilm@film_id == targetDimMovie@film_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsUpdate",
						"stgfilm, targetDimMovie exists(stgfilm@film_id == targetDimMovie@film_id,",
						"     negate:true,",
						"     broadcast: 'auto')~> notExistsInsert",
						"existsUpdate alterRow(updateIf(notEquals(iifNull(stgfilm@title,'NULL',stgfilm@title),iifNull(targetDimMovie@title,'NULL',targetDimMovie@title))),",
						"     updateIf(notEquals(iifNull(stgfilm@description,'NULL',stgfilm@description),iifNull(targetDimMovie@description,'NULL',targetDimMovie@description)))) ~> updateIf",
						"updateIf sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          film_id as integer,",
						"          title as string,",
						"          description as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['film_id'],",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          film_id = targetDimMovie@film_id,",
						"          title = stgfilm@title,",
						"          description = stgfilm@description",
						"     )) ~> updateDimMovie",
						"notExistsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          film_id as integer,",
						"          title as string,",
						"          description as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          film_id,",
						"          title,",
						"          description",
						"     )) ~> insertDimMovie"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_dim_year')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "map_year",
								"type": "DatasetReference"
							},
							"name": "mapyear"
						},
						{
							"dataset": {
								"referenceName": "dim_year",
								"type": "DatasetReference"
							},
							"name": "targetDimYear"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "dim_year",
								"type": "DatasetReference"
							},
							"name": "insertDimYear"
						},
						{
							"dataset": {
								"referenceName": "dim_year",
								"type": "DatasetReference"
							},
							"name": "updateDimYear"
						}
					],
					"transformations": [
						{
							"name": "notExistsInsert"
						},
						{
							"name": "existsUpdate"
						},
						{
							"name": "updateIf"
						}
					],
					"scriptLines": [
						"source(output(",
						"          year_id as integer,",
						"          year as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapyear",
						"source(output(",
						"          date_id as integer,",
						"          year as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetDimYear",
						"mapyear, targetDimYear exists(year_id == date_id,",
						"     negate:true,",
						"     broadcast: 'auto')~> notExistsInsert",
						"mapyear, targetDimYear join(year_id == date_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsUpdate",
						"existsUpdate alterRow(updateIf(notEquals(iifNull(mapyear@year,-1,mapyear@year),iifNull(targetDimYear@year,-1,targetDimYear@year)))) ~> updateIf",
						"notExistsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          date_id as integer,",
						"          year as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          date_id = year_id,",
						"          year",
						"     )) ~> insertDimYear",
						"updateIf sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          date_id as integer,",
						"          year as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['date_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          date_id = targetDimYear@year,",
						"          year = mapyear@year",
						"     )) ~> updateDimYear"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_fact_film')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "stg_film",
								"type": "DatasetReference"
							},
							"name": "stgfilm"
						},
						{
							"dataset": {
								"referenceName": "map_director",
								"type": "DatasetReference"
							},
							"name": "mapdirector"
						},
						{
							"dataset": {
								"referenceName": "map_year",
								"type": "DatasetReference"
							},
							"name": "mapyear"
						},
						{
							"dataset": {
								"referenceName": "map_film",
								"type": "DatasetReference"
							},
							"name": "mapfilm"
						},
						{
							"dataset": {
								"referenceName": "fact_film",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "fact_film",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "join1"
						},
						{
							"name": "join2"
						},
						{
							"name": "join3"
						},
						{
							"name": "select1"
						},
						{
							"name": "RemoveColumns1",
							"description": "Autogenerated by data preview actions"
						},
						{
							"name": "select2"
						}
					],
					"scriptLines": [
						"source(output(",
						"          film_id as integer,",
						"          title as string,",
						"          description as string,",
						"          director as string,",
						"          film_year as integer,",
						"          runtime_minutes as integer,",
						"          rating as double,",
						"          votes as integer,",
						"          revenue_millions as double,",
						"          metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stgfilm",
						"source(output(",
						"          director_id as integer,",
						"          director as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapdirector",
						"source(output(",
						"          year_id as integer,",
						"          year as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapyear",
						"source(output(",
						"          film_id as integer,",
						"          title as string,",
						"          film_year as integer,",
						"          director as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapfilm",
						"source(output(",
						"          runtime_minutes as double,",
						"          rating as double,",
						"          revenue_millions as double,",
						"          votes as integer,",
						"          metascore as integer,",
						"          film_id as integer,",
						"          director_id as integer,",
						"          year_id as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source1",
						"stgfilm, mapdirector join(stgfilm@director == mapdirector@director,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"join1, mapyear join(film_year == year,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"join2, mapfilm join(stgfilm@film_id == mapfilm@film_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join3",
						"join3 select(mapColumn(",
						"          film_id = stgfilm@film_id,",
						"          title = stgfilm@title,",
						"          description,",
						"          director = stgfilm@director,",
						"          film_year = stgfilm@film_year,",
						"          runtime_minutes,",
						"          rating,",
						"          votes,",
						"          revenue_millions,",
						"          metascore,",
						"          film_id = mapfilm@film_id,",
						"          director_id,",
						"          director = mapdirector@director,",
						"          year_id = mapfilm@film_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1 select(mapColumn(",
						"          film_id,",
						"          runtime_minutes,",
						"          rating,",
						"          votes,",
						"          revenue_millions,",
						"          metascore,",
						"          director_id,",
						"          year_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> RemoveColumns1",
						"RemoveColumns1 select(mapColumn(",
						"          film_id,",
						"          runtime_minutes,",
						"          rating,",
						"          votes,",
						"          revenue_millions,",
						"          metascore,",
						"          director_id,",
						"          year_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"select2 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          runtime_minutes as double,",
						"          rating as double,",
						"          revenue_millions as double,",
						"          votes as integer,",
						"          metascore as integer,",
						"          film_id as integer,",
						"          director_id as integer,",
						"          year_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 1000,",
						"     preSQLs:['TRUNCATE TABLE dbo.fact_film\\n'],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          runtime_minutes,",
						"          rating,",
						"          revenue_millions,",
						"          votes,",
						"          metascore,",
						"          film_id,",
						"          director_id,",
						"          year_id",
						"     )) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_landing')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "blob_land_movies",
								"type": "DatasetReference"
							},
							"name": "bloblanding"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "move_db_landing",
								"type": "DatasetReference"
							},
							"name": "tomoviesdblanding"
						}
					],
					"transformations": [],
					"scriptLines": [
						"source(output(",
						"          Rank as string,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as string,",
						"          {Runtime (Minutes)} as string,",
						"          Rating as string,",
						"          Votes as string,",
						"          {Revenue (Millions)} as string,",
						"          Metascore as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> bloblanding",
						"bloblanding sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          Rank as integer,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as integer,",
						"          Runtime_Minutes as integer,",
						"          Rating as double,",
						"          Votes as integer,",
						"          Revenue_Millions as double,",
						"          Metascore as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     truncate:true,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          Rank,",
						"          Title,",
						"          Genre,",
						"          Description,",
						"          Director,",
						"          Actors,",
						"          Year,",
						"          Runtime_Minutes = {Runtime (Minutes)},",
						"          Rating,",
						"          Votes,",
						"          Revenue_Millions = {Revenue (Millions)},",
						"          Metascore",
						"     )) ~> tomoviesdblanding"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_map_actor')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "move_db_landing",
								"type": "DatasetReference"
							},
							"name": "landMovies"
						},
						{
							"dataset": {
								"referenceName": "map_actor",
								"type": "DatasetReference"
							},
							"name": "targetMapActors"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "map_actor",
								"type": "DatasetReference"
							},
							"name": "loadintomapactors"
						},
						{
							"dataset": {
								"referenceName": "map_actor",
								"type": "DatasetReference"
							},
							"name": "insertMapActor"
						}
					],
					"transformations": [
						{
							"name": "splitActors"
						},
						{
							"name": "flattenActors"
						},
						{
							"name": "distinctActor"
						},
						{
							"name": "selectActors"
						},
						{
							"name": "trimActors"
						},
						{
							"name": "existsUpdate"
						},
						{
							"name": "updateIfExists"
						},
						{
							"name": "notExistsInsert"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Rank as integer,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as integer,",
						"          Runtime_Minutes as integer,",
						"          Rating as double,",
						"          Votes as integer,",
						"          Revenue_Millions as double,",
						"          Metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> landMovies",
						"source(output(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetMapActors",
						"landMovies derive(Actors = split(Actors, ',')) ~> splitActors",
						"splitActors foldDown(unroll(Actors),",
						"     mapColumn(",
						"          Rank,",
						"          Title,",
						"          Genre,",
						"          Description,",
						"          Director,",
						"          Actors,",
						"          Year,",
						"          {Runtime (Minutes)} = Runtime_Minutes,",
						"          Rating,",
						"          Votes,",
						"          {Revenue (Millions)} = Revenue_Millions,",
						"          Metascore",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flattenActors",
						"trimActors aggregate(groupBy(Actors),",
						"     each(match(name=='Rank'), $$ = first($$))) ~> distinctActor",
						"distinctActor select(mapColumn(",
						"          Actors",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectActors",
						"flattenActors derive(Actors = trim(Actors)) ~> trimActors",
						"selectActors, targetMapActors join(Actors == actor,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsUpdate",
						"existsUpdate alterRow(updateIf(notEquals(iifNull(Actors,'NULL',Actors),iifNull(actor,'NULL',actor)))) ~> updateIfExists",
						"selectActors, targetMapActors exists(Actors == actor,",
						"     negate:true,",
						"     broadcast: 'auto')~> notExistsInsert",
						"updateIfExists sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['actor_id'],",
						"     format: 'table',",
						"     batchSize: 100,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          actor = Actors,",
						"          actor_id",
						"     )) ~> loadintomapactors",
						"notExistsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          actor = Actors",
						"     )) ~> insertMapActor"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_map_dir')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "move_db_landing",
								"type": "DatasetReference"
							},
							"name": "landingmovies"
						},
						{
							"dataset": {
								"referenceName": "map_director",
								"type": "DatasetReference"
							},
							"name": "mapdirector"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "map_director",
								"type": "DatasetReference"
							},
							"name": "sinkMapDirector"
						},
						{
							"dataset": {
								"referenceName": "map_director",
								"type": "DatasetReference"
							},
							"name": "insertMapDirector"
						}
					],
					"transformations": [
						{
							"name": "distinctDirector"
						},
						{
							"name": "existsUpdate"
						},
						{
							"name": "updateIf"
						},
						{
							"name": "notExistsInsert"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Rank as integer,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as integer,",
						"          Runtime_Minutes as integer,",
						"          Rating as double,",
						"          Votes as integer,",
						"          Revenue_Millions as double,",
						"          Metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> landingmovies",
						"source(output(",
						"          director_id as integer,",
						"          director as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapdirector",
						"landingmovies aggregate(groupBy(Director),",
						"     each(match(name!='Director'), $$ = first($$))) ~> distinctDirector",
						"distinctDirector, mapdirector join(distinctDirector@Director == mapdirector@director,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsUpdate",
						"existsUpdate alterRow(updateIf(notEquals(iifNull(mapdirector@director,'NULL',mapdirector@director),iifNull(distinctDirector@Director,'NULL',distinctDirector@Director)))) ~> updateIf",
						"distinctDirector, mapdirector exists(distinctDirector@Director == mapdirector@director,",
						"     negate:true,",
						"     broadcast: 'auto')~> notExistsInsert",
						"updateIf sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          director_id as integer,",
						"          director as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['director_id'],",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          director = distinctDirector@Director,",
						"          director_id",
						"     )) ~> sinkMapDirector",
						"notExistsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          director_id as integer,",
						"          director as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          director = Director",
						"     )) ~> insertMapDirector"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_map_film')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "move_db_landing",
								"type": "DatasetReference"
							},
							"name": "landmovies"
						},
						{
							"dataset": {
								"referenceName": "map_film",
								"type": "DatasetReference"
							},
							"name": "targetMapFilm"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "map_film",
								"type": "DatasetReference"
							},
							"name": "insertMapFilm"
						},
						{
							"dataset": {
								"referenceName": "map_film",
								"type": "DatasetReference"
							},
							"name": "updateMapFilm"
						}
					],
					"transformations": [
						{
							"name": "selectTitleDirYear"
						},
						{
							"name": "notExistsInsert"
						},
						{
							"name": "existsUpdate"
						},
						{
							"name": "updateIf"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Rank as integer,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as integer,",
						"          Runtime_Minutes as integer,",
						"          Rating as double,",
						"          Votes as integer,",
						"          Revenue_Millions as double,",
						"          Metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> landmovies",
						"source(output(",
						"          film_id as integer,",
						"          title as string,",
						"          film_year as integer,",
						"          director as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetMapFilm",
						"landmovies select(mapColumn(",
						"          Title,",
						"          Director,",
						"          Year",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectTitleDirYear",
						"selectTitleDirYear, targetMapFilm exists(selectTitleDirYear@Title == targetMapFilm@title",
						"     && Year == film_year,",
						"     negate:true,",
						"     broadcast: 'auto')~> notExistsInsert",
						"selectTitleDirYear, targetMapFilm join(selectTitleDirYear@Title == targetMapFilm@title",
						"     && selectTitleDirYear@Director == targetMapFilm@director",
						"     && Year == film_year,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsUpdate",
						"existsUpdate alterRow(updateIf(notEquals(iifNull(selectTitleDirYear@Title,'NULL',selectTitleDirYear@Title),iifNull(targetMapFilm@title,'NULL',targetMapFilm@title))),",
						"     updateIf(notEquals(iifNull(selectTitleDirYear@Director,'NULL',selectTitleDirYear@Director),iifNull(targetMapFilm@director,'NULL',targetMapFilm@director))),",
						"     updateIf(notEquals(iifNull(Year,-1,Year),iifNull(film_year,-1,film_year)))) ~> updateIf",
						"notExistsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          film_id as integer,",
						"          title as string,",
						"          film_year as integer,",
						"          director as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          title = Title,",
						"          film_year = Year,",
						"          director = Director",
						"     )) ~> insertMapFilm",
						"updateIf sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          film_id as integer,",
						"          title as string,",
						"          film_year as integer,",
						"          director as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['film_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          film_id,",
						"          title = selectTitleDirYear@Title,",
						"          film_year = Year,",
						"          director = selectTitleDirYear@Director",
						"     )) ~> updateMapFilm"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_map_genre')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "move_db_landing",
								"type": "DatasetReference"
							},
							"name": "landingmovies"
						},
						{
							"dataset": {
								"referenceName": "map_genre",
								"type": "DatasetReference"
							},
							"name": "targetMapGenre"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "map_genre",
								"type": "DatasetReference"
							},
							"name": "insertMapGenre"
						},
						{
							"dataset": {
								"referenceName": "map_genre",
								"type": "DatasetReference"
							},
							"name": "updateMapGenre"
						}
					],
					"transformations": [
						{
							"name": "splitGenre"
						},
						{
							"name": "flattenGenre"
						},
						{
							"name": "distinctGenre"
						},
						{
							"name": "selectGenre"
						},
						{
							"name": "trimGenre"
						},
						{
							"name": "notExistsInsert"
						},
						{
							"name": "existsUpdate"
						},
						{
							"name": "updateIf"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Rank as integer,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as integer,",
						"          Runtime_Minutes as integer,",
						"          Rating as double,",
						"          Votes as integer,",
						"          Revenue_Millions as double,",
						"          Metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> landingmovies",
						"source(output(",
						"          genre_id as integer,",
						"          genre as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetMapGenre",
						"landingmovies derive(Genre = split(Genre, ',')) ~> splitGenre",
						"splitGenre foldDown(unroll(Genre),",
						"     mapColumn(",
						"          Rank,",
						"          Title,",
						"          Genre,",
						"          Description,",
						"          Director,",
						"          Actors,",
						"          Year,",
						"          {Runtime (Minutes)} = Runtime_Minutes,",
						"          Rating,",
						"          Votes,",
						"          {Revenue (Millions)} = Revenue_Millions,",
						"          Metascore",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flattenGenre",
						"trimGenre aggregate(groupBy(Genre),",
						"     each(match(name=='Rank'), $$ = first($$))) ~> distinctGenre",
						"distinctGenre select(mapColumn(",
						"          Genre",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectGenre",
						"flattenGenre derive(Genre = trim(Genre)) ~> trimGenre",
						"selectGenre, targetMapGenre exists(selectGenre@Genre == targetMapGenre@genre,",
						"     negate:true,",
						"     broadcast: 'auto')~> notExistsInsert",
						"selectGenre, targetMapGenre join(selectGenre@Genre == targetMapGenre@genre,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsUpdate",
						"existsUpdate alterRow(updateIf(notEquals(iifNull(selectGenre@Genre,'NULL',selectGenre@Genre),iifNull(targetMapGenre@genre,'NULL',targetMapGenre@genre)))) ~> updateIf",
						"notExistsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          genre_id as integer,",
						"          genre as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          genre = Genre",
						"     )) ~> insertMapGenre",
						"updateIf sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          genre_id as integer,",
						"          genre as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['genre_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          genre_id,",
						"          genre = selectGenre@Genre",
						"     )) ~> updateMapGenre"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_map_year')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "move_db_landing",
								"type": "DatasetReference"
							},
							"name": "landingmovies"
						},
						{
							"dataset": {
								"referenceName": "map_year",
								"type": "DatasetReference"
							},
							"name": "targetMapYear"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "map_year",
								"type": "DatasetReference"
							},
							"name": "insertMapYear"
						},
						{
							"dataset": {
								"referenceName": "map_year",
								"type": "DatasetReference"
							},
							"name": "updateMapYear"
						}
					],
					"transformations": [
						{
							"name": "selectYear"
						},
						{
							"name": "distinctYear"
						},
						{
							"name": "notExistsInsert"
						},
						{
							"name": "existsUpdate"
						},
						{
							"name": "updateIf"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Rank as integer,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as integer,",
						"          Runtime_Minutes as integer,",
						"          Rating as double,",
						"          Votes as integer,",
						"          Revenue_Millions as double,",
						"          Metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> landingmovies",
						"source(output(",
						"          year_id as integer,",
						"          year as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetMapYear",
						"landingmovies select(mapColumn(",
						"          year = Year",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectYear",
						"selectYear aggregate(groupBy(year),",
						"     each(match(name!='year'), $$ = first($$))) ~> distinctYear",
						"distinctYear, targetMapYear exists(distinctYear@year == targetMapYear@year,",
						"     negate:true,",
						"     broadcast: 'auto')~> notExistsInsert",
						"distinctYear, targetMapYear join(distinctYear@year == targetMapYear@year,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> existsUpdate",
						"existsUpdate alterRow(updateIf(notEquals(iifNull(targetMapYear@year,-1,targetMapYear@year),iifNull(distinctYear@year,-1,distinctYear@year)))) ~> updateIf",
						"notExistsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          year_id as integer,",
						"          year as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          year",
						"     )) ~> insertMapYear",
						"updateIf sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          year_id as integer,",
						"          year as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['year_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          year_id,",
						"          year = distinctYear@year",
						"     )) ~> updateMapYear"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_stg_actor')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "move_db_landing",
								"type": "DatasetReference"
							},
							"name": "landmovies"
						},
						{
							"dataset": {
								"referenceName": "map_actor",
								"type": "DatasetReference"
							},
							"name": "mapactor"
						},
						{
							"dataset": {
								"referenceName": "stg_actor",
								"type": "DatasetReference"
							},
							"name": "stgactor"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "stg_actor",
								"type": "DatasetReference"
							},
							"name": "insertstgactor"
						}
					],
					"transformations": [
						{
							"name": "splitActors"
						},
						{
							"name": "flattenActors"
						},
						{
							"name": "trimActors"
						},
						{
							"name": "joinMapActor"
						},
						{
							"name": "distinctActor"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Rank as integer,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as integer,",
						"          Runtime_Minutes as integer,",
						"          Rating as double,",
						"          Votes as integer,",
						"          Revenue_Millions as double,",
						"          Metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> landmovies",
						"source(output(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapactor",
						"source(output(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     allowSchemaDrift: false,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stgactor",
						"landmovies derive(Actors = split(Actors, ',')) ~> splitActors",
						"splitActors foldDown(unroll(Actors),",
						"     mapColumn(",
						"          Rank,",
						"          Title,",
						"          Genre,",
						"          Description,",
						"          Director,",
						"          Actors,",
						"          Year,",
						"          {Runtime (Minutes)} = Runtime_Minutes,",
						"          Rating,",
						"          Votes,",
						"          {Revenue (Millions)} = Revenue_Millions,",
						"          Metascore",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flattenActors",
						"flattenActors derive(Actors = trim(Actors)) ~> trimActors",
						"trimActors, mapactor join(Actors == actor,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinMapActor",
						"joinMapActor aggregate(groupBy(Actors),",
						"     each(match(name!='Actors'), $$ = first($$))) ~> distinctActor",
						"distinctActor sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     truncate:true,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          actor_id,",
						"          actor",
						"     )) ~> insertstgactor"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_stg_actor_film_assoc')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "move_db_landing",
								"type": "DatasetReference"
							},
							"name": "landingmovies"
						},
						{
							"dataset": {
								"referenceName": "map_actor",
								"type": "DatasetReference"
							},
							"name": "mapactor"
						},
						{
							"dataset": {
								"referenceName": "map_film",
								"type": "DatasetReference"
							},
							"name": "mapfilm"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "stg_actor_film_assoc",
								"type": "DatasetReference"
							},
							"name": "insertStgActorFilmAssoc"
						}
					],
					"transformations": [
						{
							"name": "actorsSplit"
						},
						{
							"name": "flattenActors"
						},
						{
							"name": "trimActors"
						},
						{
							"name": "joinMapFilm"
						},
						{
							"name": "selectActorsTitleYearDIr"
						},
						{
							"name": "joinMapActor"
						},
						{
							"name": "actorsFilmId"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Rank as integer,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as integer,",
						"          Runtime_Minutes as integer,",
						"          Rating as double,",
						"          Votes as integer,",
						"          Revenue_Millions as double,",
						"          Metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> landingmovies",
						"source(output(",
						"          actor_id as integer,",
						"          actor as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapactor",
						"source(output(",
						"          film_id as integer,",
						"          title as string,",
						"          film_year as integer,",
						"          director as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapfilm",
						"landingmovies derive(Actors = split(Actors, ',')) ~> actorsSplit",
						"actorsSplit foldDown(unroll(Actors),",
						"     mapColumn(",
						"          Rank,",
						"          Title,",
						"          Genre,",
						"          Description,",
						"          Director,",
						"          Actors,",
						"          Year,",
						"          {Runtime (Minutes)} = Runtime_Minutes,",
						"          Rating,",
						"          Votes,",
						"          {Revenue (Millions)} = Revenue_Millions,",
						"          Metascore",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flattenActors",
						"flattenActors derive(Actors = trim(Actors)) ~> trimActors",
						"selectActorsTitleYearDIr, mapfilm join(selectActorsTitleYearDIr@Title == mapfilm@title",
						"     && selectActorsTitleYearDIr@Director == mapfilm@director,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinMapFilm",
						"trimActors select(mapColumn(",
						"          Actors,",
						"          Title,",
						"          Director,",
						"          Year",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> selectActorsTitleYearDIr",
						"actorsFilmId, mapactor join(Actors == actor,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'off')~> joinMapActor",
						"joinMapFilm select(mapColumn(",
						"          Actors,",
						"          film_id",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> actorsFilmId",
						"joinMapActor sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          stg_actor_film_id as integer,",
						"          actor_id as integer,",
						"          film_id as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     truncate:true,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          actor_id,",
						"          film_id",
						"     )) ~> insertStgActorFilmAssoc"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/load_stg_film')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "move_db_landing",
								"type": "DatasetReference"
							},
							"name": "landingmovie"
						},
						{
							"dataset": {
								"referenceName": "map_film",
								"type": "DatasetReference"
							},
							"name": "mapfilm"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "stg_film",
								"type": "DatasetReference"
							},
							"name": "insertStgFilm"
						}
					],
					"transformations": [
						{
							"name": "joinMapFilm"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Rank as integer,",
						"          Title as string,",
						"          Genre as string,",
						"          Description as string,",
						"          Director as string,",
						"          Actors as string,",
						"          Year as integer,",
						"          Runtime_Minutes as integer,",
						"          Rating as double,",
						"          Votes as integer,",
						"          Revenue_Millions as double,",
						"          Metascore as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> landingmovie",
						"source(output(",
						"          film_id as integer,",
						"          title as string,",
						"          film_year as integer,",
						"          director as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> mapfilm",
						"landingmovie, mapfilm join(landingmovie@Title == mapfilm@title",
						"     && landingmovie@Director == mapfilm@director",
						"     && Year == film_year,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinMapFilm",
						"joinMapFilm sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          film_id as integer,",
						"          title as string,",
						"          description as string,",
						"          director as string,",
						"          film_year as integer,",
						"          runtime_minutes as integer,",
						"          rating as double,",
						"          votes as integer,",
						"          revenue_millions as double,",
						"          metascore as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     truncate:true,",
						"     format: 'table',",
						"     batchSize: 100,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          film_id,",
						"          title = landingmovie@Title,",
						"          description = Description,",
						"          director = landingmovie@Director,",
						"          film_year,",
						"          runtime_minutes = Runtime_Minutes,",
						"          rating = Rating,",
						"          votes = Votes,",
						"          revenue_millions = Revenue_Millions,",
						"          metascore = Metascore",
						"     )) ~> insertStgFilm"
					]
				}
			},
			"dependsOn": []
		}
	]
}